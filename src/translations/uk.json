{
  "header": {
    "features": "Функції",
    "news": "Новини",
    "faq": "Поширені запитання",
    "faqLink": "Поширені запитання",
    "updates": "Оновлення",
    "selectLanguage": "Вибрати мову",
    "changeLanguageTooltip": "Змінити мову",
    "lightMode": "Світла тема",
    "darkMode": "Темна тема",
    "openMenu": "Відкрити меню",
    "closeMenu": "Закрити меню",
    "settings": "Налаштування",
    "signOut": "Вийти",
    "deleteAccount": "Видалити обліковий запис",
    "deleteAccountConfirmTitle": "Підтвердити видалення облікового запису",
    "deleteAccountConfirmMessage": "Ви впевнені, що хочете видалити свій обліковий запис? Цю дію не можна скасувати.",
    "cancel": "Скасувати",
    "confirmDelete": "Підтвердити видалення",
    "signIn": "Увійти",
    "docs": "Документація"
  },
  "hero": {
    "title": "Ласкаво просимо до BrainMessenger",
    "subtitle": "Ваша розумна платформа для спілкування",
    "getStarted": "Почати",
    "learnMore": "Дізнатись більше",
    "downloadButton": "Завантажити",
    "downloadWindows": "Завантажити для Windows",
    "downloadAndroid": "Завантажити для Android"
  },
  "features": {
    "featuresTitle": "Ключові функції",
    "featuresSubtitle": "Дізнайтесь, що робить нас унікальними",
    "secureMessaging": "Безпечні повідомлення",
    "secureMessagingDesc": "Наскрізне шифрування для вашої конфіденційності",
    "smartAssistant": "Розумний асистент",
    "smartAssistantDesc": "ІІ-помічник завжди під рукою",
    "crossPlatform": "Крос-платформність",
    "crossPlatformDesc": "Використовуйте на будь-якому пристрої, де завгодно",
    "groupChats": "Групові чати",
    "groupChatsDesc": "Спілкуйтеся з кількома людьми одночасно",
    "privacyFirst": "Конфіденційність перш за все",
    "privacyFirstDesc": "Ваші дані - ваші, завжди"
  },
  "news": {
    "latestNews": "Останні новини",
    "readMore": "Читати далі",
    "newsDate": "Опубліковано"
  },
  "faq": {
    "title": "Поширені запитання",
    "subtitle": "Знайдіть відповіді на поширені запитання про BrainMessenger",
    "searchAlt": "Іконка пошуку",
    "searchPlaceholder": "Пошук запитань...",
    "allQuestions": "Всі запитання",
    "noResults": "За вашим запитом не знайдено жодного запитання.",
    "categories": {
      "general": "Загальні",
      "technical": "Технічні",
      "security": "Безпека",
      "pricing": "Ціни",
      "generalProject": "Загальні питання про проект",
      "technicalQuestions": "Технічні питання",
      "developmentProcesses": "Процеси розробки",
      "statusRoadmapFuture": "Статус, дорожня карта та майбутнє",
      "challengesOpportunitiesLimitations": "Виклики, можливості та обмеження",
      "learnMoreContribute": "Дізнатися більше та долучитися"
    },
    "questionsData": {
      "generalProject": {
        "q1": {
          "question": "Яка основна ідея BrainMessenger? Що робить його особливим?",
          "answer": "BrainMessenger - це платформа для спілкування, яка ставить на перше місце безпеку, інтелектуальні функції та зручність користувача. Його особливість полягає в поєднанні наскрізного шифрування, ШІ-асистента та крос-платформної доступності."
        },
        "q2": {
          "question": "Які ключові принципи лежать в основі розробки BrainMessenger?",
          "answer": "Розробка базується на принципах створення цінності для користувача, якості над кількістю, прагматизму, цілісності та здоров'я як фундаменту (включаючи доступність)."
        },
        "q3": {
          "question": "Хто стоїть за проектом? Це відкрита спільнота чи команда?",
          "answer": "На даний момент проект розробляється командою ентузіастів, але ми відкриті до співпраці та внесків від спільноти."
        }
      },
      "technicalQuestions": {
        "q1": {
          "question": "Чому було обрано саме такий стек технологій (TypeScript, NestJS, React/RN, PostgreSQL/Neon, GraphQL, Kafka, Redis, Cloudflare R2 тощо)?",
          "answer": "Вибір стеку обумовлений прагненням до надійності, масштабованості, швидкості розробки та використання сучасних підходів. TypeScript забезпечує типізацію, NestJS – структуру бекенду, React/RN – гнучкість UI, а інші технології – ефективну роботу з даними, повідомленнями та файлами."
        },
        "q2": {
          "question": "Чому на старті використовується монолітна архітектура, а не одразу мікросервіси?",
          "answer": "Монолітна архітектура на старті дозволяє швидше запустити MVP та перевірити основні гіпотези. Перехід до мікросервісів планується в майбутньому для кращої масштабованості та гнучкості."
        },
        "q3": {
          "question": "Які підходи використовуються для забезпечення безпеки?",
          "answer": "Ми використовуємо наскрізне шифрування (E2EE) для всіх приватних чатів, двофакторну автентифікацію (2FA), регулярні аудити безпеки та дотримуємося найкращих практик захисту даних."
        },
        "q4": {
          "question": "Як реалізовано функціональність реального часу (обмін повідомленнями)?",
          "answer": "Для обміну повідомленнями в реальному часі використовуються WebSockets та, можливо, Kafka для обробки потоків повідомлень, що забезпечує швидку та надійну доставку."
        },
        "q5": {
          "question": "Чому використовується GraphQL замість REST API?",
          "answer": "GraphQL дозволяє клієнтам запитувати лише ті дані, які їм потрібні, зменшуючи надлишковість та покращуючи продуктивність. Це також спрощує розробку API та еволюцію схеми даних."
        },
        "q6": {
          "question": "Як керуються великі обсяги даних та файлів?",
          "answer": "Для зберігання великих обсягів даних використовується PostgreSQL (можливо, з Neon для масштабованості), а для файлів – Cloudflare R2, що забезпечує надійне та ефективне зберігання."
        }
      },
      "developmentProcesses": {
        "q1": {
          "question": "Який підхід до управління проектом та завданнями?",
          "answer": "Ми використовуємо гнучкі методології розробки (Agile/Scrum) з регулярними спринтами, плануванням та ретроспективами. Завдання відстежуються в системі управління проектами."
        },
        "q2": {
          "question": "Як забезпечується якість коду?",
          "answer": "Якість коду забезпечується через код-рев'ю, статичний аналіз (лінтери, форматери), дотримання стандартів кодування та написання тестів."
        },
        "q3": {
          "question": "Яка стратегія тестування використовується?",
          "answer": "Наша стратегія включає юніт-тести, інтеграційні тести та E2E-тести для забезпечення надійності всіх компонентів системи."
        },
        "q4": {
          "question": "Як обробляються помилки?",
          "answer": "Помилки відстежуються за допомогою систем моніторингу, логуються та аналізуються для швидкого виправлення. На клієнті передбачені механізми обробки помилок для покращення UX."
        },
        "q5": {
          "question": "Як розгортається проект?",
          "answer": "Розгортання автоматизоване за допомогою CI/CD пайплайнів, що забезпечує швидку та надійну доставку оновлень."
        },
        "q6": {
          "question": "Як моніториться система в продакшені?",
          "answer": "Система моніториться за допомогою спеціалізованих інструментів, які відстежують продуктивність, доступність та помилки в реальному часі."
        }
      },
      "statusRoadmapFuture": {
        "q1": {
          "question": "Який поточний статус проекту?",
          "answer": "Проект знаходиться на стадії активної розробки MVP. Основні функції обміну повідомленнями та безпеки реалізовані."
        },
        "q2": {
          "question": "Які наступні кроки після завершення MVP?",
          "answer": "Після MVP планується розширення функціоналу, покращення продуктивності, додавання нових інтеграцій та поступовий перехід до мікросервісної архітектури."
        },
        "q3": {
          "question": "Чи планується перехід на мікросервісну архітектуру?",
          "answer": "Так, перехід на мікросервісну архітектуру планується для забезпечення кращої масштабованості, гнучкості та незалежності розробки окремих компонентів."
        }
      },
      "challengesOpportunitiesLimitations": {
        "q1": {
          "question": "Які основні технічні виклики (підводні камені) в проекті?",
          "answer": "Основні виклики включають забезпечення високого рівня безпеки, масштабування системи під великі навантаження та реалізацію складних ШІ-функцій."
        },
        "q2": {
          "question": "Які можливості та переваги надає архітектура та стек проекту?",
          "answer": "Обраний стек та архітектура забезпечують гнучкість, швидкість розробки, високу продуктивність та можливість легко впроваджувати нові технології."
        },
        "q3": {
          "question": "Які обмеження проекту на поточному етапі (MVP)?",
          "answer": "На етапі MVP функціонал буде обмежений основними можливостями для швидкого запуску та збору зворотного зв'язку. Деякі розширені функції будуть додані пізніше."
        }
      },
      "learnMoreContribute": {
        "q1": {
          "question": "Де я можу отримати більш детальну інформацію про проект?",
          "answer": "Більш детальну інформацію можна знайти в нашій документації (посилання буде додано пізніше) та на сторінці проекту на GitHub (якщо проект відкритий)."
        },
        "q2": {
          "question": "Як я можу долучитися до розробки проекту або зробити свій внесок?",
          "answer": "Ми завжди раді новим учасникам! Зв'яжіться з нами через контактну форму на сайті або через GitHub (якщо проект відкритий), щоб обговорити можливі варіанти співпраці."
        },
        "q3": {
          "question": "Де я можу поставити додаткові запитання?",
          "answer": "Додаткові запитання можна поставити через контактну форму на сайті, в нашому ком'юніті (посилання буде додано) або створивши issue на GitHub (якщо проект відкритий)."
        }
      }
    }
  },
  "docs": {
    "general": {
      "title": "BrainMessenger - Ваш Цифровий Актив для Ефективної Комунікації",
      "subtitle": "Вступ: Побудова Системи Цінності",
      "introduction": {
        "title": "Вступ: Побудова Системи Цінності",
        "content": "Ласкаво просимо до репозиторію BrainMessenger. Це не просто черговий месенджер. Це цілеспрямований проект, спрямований на створення <strong>надійної, масштабованої та безпечної СИСТЕМИ</strong> (Принцип 9), яка стане <strong>ключовим цифровим АКТИВОМ</strong> (Принцип 10) для кожного користувача. Наша головна мета – <strong>спростити складність</strong> (принцип Маргулана Сейсембаєва), надаючи інтуїтивно зрозумілі та потужні інструменти для ефективної комунікації та взаємодії в сучасному цифровому світі.<br/><br/>BrainMessenger побудований на <strong>міцному фундаменті</strong> (Принцип 8) глибоких принципів, свідомого планування та <strong>безперервного навчання</strong> (Принцип 1). Кожен рядок коду, кожне прийняте рішення – це <strong>довгострокова інвестиція</strong> (Принцип 8) у <strong>якість</strong> (Принцип 3) та <strong>цінність</strong> (Принцип 2) нашого продукту."
      },
      "visionAndMission": {
        "title": "Бачення та Місія: Наш Довгостроковий Погляд",
        "visionTitle": "Наше Бачення:",
        "visionContent": "Створити провідний цифровий актив для комунікації, який допомагатиме мільйонам користувачів по всьому світу ефективно обмінюватися інформацією, будувати спільноти та досягати своїх цілей.",
        "missionTitle": "Наша Місія:",
        "missionContent": "Спрощувати складну взаємодію, надаючи надійний, безпечний та зручний месенджер, побудований на принципах якості, прозорості та безперервного вдосконалення."
      },
      "keyPrinciples": {
        "title": "Ключові Принципи: Фундамент Нашої Системи",
        "intro": "Наші дії та рішення керуються набором ключових принципів, які слугують <strong>фундаментом</strong> (Принцип 8) всього проекту BrainMessenger. Це не просто слова, а <strong>особисті алгоритми та стандарти (Кайдзен, Принцип 9)</strong>, розроблені через досвід та рефлексію (Принцип 1):",
        "principles": [
          "<strong>Безперервне Навчання та Зростання (Принцип 1):</strong> Процес створення BrainMessenger – це полігон для глибокого навчання в технологіях, архітектурі та психології користувачів. Ми вчимося на кожному кроці, перетворюючи помилки на уроки.",
          "<strong>Створення Цінності (Принцип 2):</strong> Користь для користувача – в основі всього. Ми будуємо те, що справді вирішує проблеми та робить життя кращим.",
          "<strong>Якість Понад Кількість (Принцип 3):</strong> Ми прагнемо робити речі добре, а не просто швидко. Надійність, продуманість та увага до деталей – наші пріоритети.",
          "<strong>Усвідомленість та Присутність (Принцип 4):</strong> Бути уважним до процесу, користувачів та команди.",
          "<strong>Здоров'я як Фундамент (Принцип 5):</strong> Фізичне та ментальне благополуччя команди (та майбутніх користувачів) – основа продуктивності та стійкості.",
          "<strong>Відповідальність та Проактивність (Принцип 6):</strong> Ми беремо відповідальність за результат та діємо превентивно.",
          "<strong>Цілісність (Принцип 7):</strong> Наші слова відповідають нашим діям.",
          "<strong>Довгострокове Мислення (Принцип 8):</strong> Ми інвестуємо час та зусилля з прицілом на майбутнє.",
          "<strong>Система та Оптимізація (Принцип 9):</strong> Ми будуємо процеси та архітектуру як систему, постійно шукаючи шляхи підвищення ефективності (Кайдзен).",
          "<strong>Створення Багатства > Заробляння Грошей (Принцип 10):</strong> Фокус на створенні АКТИВУ (BrainMessenger), який приносить цінність та працює в довгостроковій перспективі.",
          "<strong>Гнучкість та Адаптивність (Принцип 11):</strong> Готовність змінювати тактику та інструменти, зберігаючи бачення.",
          "<strong>Прагматизм та Реалізм (Принцип 12):</strong> Прийняття рішень на основі реальних даних та можливостей.",
          "<strong>Наполегливість (Принцип 13):</strong> Не здаватися перед труднощами, витягувати уроки з невдач.",
          "<strong>Використання Зовнішньої Експертизи та Зворотного Зв'язку (Принцип 14):</strong> Ми вчимося в інших, прислухаємося до конструктивної критики.",
          "<strong>Схильність до Дії (Принцип 15):</strong> На ранніх етапах важливіше почати робити та отримувати зворотний зв'язок, ніж нескінченно планувати."
        ],
        "outro": "Ці принципи, натхненні філософією Маргулана Сейсембаєва та практиками провідних ІТ-компаній, формують нашу культуру та підхід до розробки."
      },
      "aboutMVP": {
        "title": "Про Проект BrainMessenger (Фокус на MVP)",
        "intro": "Наш поточний фокус – на розробці <strong>Мінімально Життєздатного Продукту (MVP)</strong>. MVP – це перший, <strong>прагматичний</strong> (Принцип 12) крок до реалізації нашого бачення. Ми будуємо <strong>міцний технічний фундамент</strong> (Принцип 8), який дозволить нам швидко та ефективно розвивати продукт у майбутньому.",
        "featuresTitle": "MVP включає базові, але <strong>високоякісні та надійні</strong> (Принцип 3) функції, що надають ключову <strong>цінність</strong> (Принцип 2):",
        "features": [
          "<strong>Базовий Обмін Повідомленнями:</strong> Надсилання та отримання текстових повідомлень в особистих чатах та групах/каналах.",
          "<strong>Обмін Файлами:</strong> Завантаження та завантаження файлів (з оптимізацією зображень).",
          "<strong>Канали та Групи:</strong> Базове створення груп/каналів, приєднання до публічних каналів та читання контенту.",
          "<strong>Базове Управління Обліковим Записом:</strong> Реєстрація, вхід/вихід, редагування профілю (ім'я, аватар), базові налаштування безпеки.",
          "<strong>Основні Налаштування UI:</strong> Вибір теми (Світла/Темна), базові налаштування сповіщень та мови.",
          "<strong>Базова Безпека:</strong> Шифрування даних (TLS, хешування паролів, базові заходи проти SQLi/XSS/DDoS), підтвердження електронної пошти під час реєстрації.",
          "<strong>Адаптивний UI:</strong> Інтерфейс, адаптований для мобільних (Android, iOS) та веб-платформ.",
          "<strong>Базова Багатомовність:</strong> Підтримка кількох мов інтерфейсу (англійська, російська та інші згідно DocLocIn.md)."
        ],
        "outro": "Функціонал за межами MVP (аудіо/відеодзвінки, розширені функції безпеки/конфіденційності, преміум-підписка, повний набір анімацій, інтеграції ШІ) заплановано на наступні етапи Дорожньої карти."
      },
      "howWeBuild": {
        "title": "Як Ми Будуємо: Історія Створення та Процес Кайдзен",
        "intro": "Процес створення BrainMessenger – це жива історія, заснована на наших принципах. Ми будуємо його <strong>систематично</strong> (Принцип 9), крок за кроком, документуючи кожен етап та постійно шукаючи можливості для <strong>вдосконалення (Кайдзен)</strong>.",
        "steps": [
          "<strong>Усвідомлене Планування (Принцип 4):</strong> Проект розпочався з чіткого визначення глобальних цілей та їх декомпозиції на досяжні етапи (Дорожня карта).",
          "<strong>Вибір Фундаменту (Принцип 8, 12):</strong> Ми ретельно відібрали стек технологій – надійні та <strong>прагматичні</strong> інструменти (TypeScript, NestJS, React/RN, PostgreSQL/Neon, Cloudflare R2, Kafka, Redis), що формують <strong>міцний технічний фундамент</strong>.",
          "<strong>Побудова Ядра MVP:</strong> Реалізація розпочалася з базових, критично важливих частин системи (Аутентифікація, Базовий UI, Інфраструктура, Обробка Файлів). Ми застосовуємо <strong>Схильність до Дії</strong> (Принцип 15), зосереджуючись на побудові робочих компонентів, навіть якщо вони поки що мінімальні.",
          "<strong>Безперервне Навчання та Застосування Знань (Принцип 1):</strong> Кожне нове завдання, особливо пов'язане з вивченням або інтеграцією технологій (як видно у <a href=\"https://www.notion.so/2025-2026-1576e78881b7435e9c3c2cf174e61b91?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Відео Трекері</a> та завданнях), розглядається як можливість для зростання. Ми документуємо цей процес за допомогою відео та рефлексії (Кайдзен-Година).",
          "<strong>Системний Підхід до Якості (Принцип 3, 9):</strong> Ми інтегруємо тестування на ранніх етапах циклу розробки (Unit-тести), налаштовуємо CI/CD пайплайни для автоматичних перевірок, і використовуємо інструменти моніторингу (Prometheus, Grafana, Sentry) та логування (Winston, ELK) для безперервного контролю за <strong>здоров'ям системи</strong> (Принцип 5) в реальному часі.",
          "<strong>Документація як Частина Системи Знань:</strong> Весь процес розробки, архітектурні рішення, стандарти та вимоги ретельно документуються. Це не просто формальність, а частина створення <strong>системи знань</strong>, яка прискорює онбординг, спрощує підтримку та дозволяє приймати обґрунтовані рішення в майбутньому."
        ],
        "outro": "Ми будуємо BrainMessenger як живий, еволюціонуючий організм, постійно адаптуючись та вдосконалюючись на основі наших принципів та зворотного зв'язку від процесу розробки та майбутніх користувачів."
      },
      "technologyStack": {
        "title": "Стек Технологій: Наші Інструменти для Створення Активу",
        "intro": "Ми обрали стек, який є <strong>прагматичним</strong> (Принцип 12), <strong>надійним</strong> (Принцип 3) та <strong>масштабованим</strong> (Принцип 8) для створення нашого <strong>цифрового АКТИВУ</strong>.",
        "stack": [
          "<strong>Мова:</strong> <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">TypeScript</a> - Статична типізація для підвищення якості та надійності коду.",
          "<strong>Бекенд:</strong> <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Node.js</a>, <a href=\"https://nestjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">NestJS</a> - Ефективний та структурований фреймворк для серверної логіки та GraphQL API.",
          "<strong>Фронтенд:</strong> <a href=\"https://react.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React</a>, <a href=\"https://nextjs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js</a> (Веб), <a href=\"https://reactnative.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">React Native</a> (Мобільний/Десктоп) - Крос-платформна розробка UI з фокусом на продуктивності.",
          "<strong>API:</strong> <a href=\"https://graphql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">GraphQL</a> - Гнучка взаємодія між клієнтом та сервером.",
          "<strong>Реальний час:</strong> WebSockets - Миттєва доставка повідомлень.",
          "<strong>База даних:</strong> <a href=\"https://www.postgresql.org/\" target=\"_blank\" rel=\"noopener noreferrer\">PostgreSQL</a> (через <a href=\"https://neon.tech/\" target=\"_blank\" rel=\"noopener noreferrer\">Neon</a>) - Надійна та масштабована база даних. Neon як керований сервіс зменшує операційні витрати (Прагматизм).",
          "<strong>ORM:</strong> <a href=\"https://www.prisma.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Prisma</a> - Типобезопасное и надежное взаимодействие с базой данных, защита от SQL-инъекций (Качество, Безпека).",
          "<strong>Кешування:</strong> <a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis</a> - Высокопродуктивное кеширование и управление состоянием.",
          "<strong>Черги:</strong> <a href=\"https://kafka.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Kafka</a> - Надійна асинхронна обробка завдань.",
          "<strong>Зберігання файлів:</strong> <a href=\"https://www.cloudflare.com/developer/r2/\" target=\"_blank\" rel=\"noopener noreferrer\">Cloudflare R2</a> - Об'єктне сховище з вигідними тарифами та без плати за исходящий трафік (Прагматизм, АКТИВ).",
          "<strong>Сповіщення:</strong> <a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Firebase</a> - Керований сервіс для push-сповіщень.",
          "<strong>Електронна пошта/2FA:</strong> <a href=\"https://developers.google.com/gmail/api\" target=\"_blank\" rel=\"noopener noreferrer\">Gmail API</a> - Надійна доставка транзакційних писем (коди підтвердження, 2FA).",
          "<strong>Платежі:</strong> <a href=\"https://stripe.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Stripe</a>, Cryptomus (За пределами MVP) - Монетизация АКТИВУ, Прагматизм.",
          "<strong>Тестирование:</strong> Jest, Cypress, Detox, k6, OWASP ZAP/Burp Suite (план) - Комплексный подход к обеспечению качества.",
          "<strong>Развертывание:</strong> <a href=\"https://vercel.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a> (Веб), Docker, <a href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes</a> - Автоматизованное и масштабированное развертывание.",
          "<strong>Мониторинг:</strong> Prometheus, Grafana, Sentry (план) - Видимость системы и анализ Кайдзен."
        ]
      },
      "architecture": {
        "title": "Архітектура: Еволюція Системи",
        "intro": "Наразі BrainMessenger реалізований як <strong>монолітний додаток на базі NestJS</strong>. Це <strong>прагматичне</strong> (Принцип 12) рішення для MVP, що дозволяє швидко запустити продукт та перевірити основні гіпотези.",
        "future": "У майбутньому, зі зростанням проекту та збільшенням навантаження, ми плануємо поетапний перехід до <strong>мікросервісної архітектури</strong> з використанням <strong>Strangler Pattern</strong>. Це <strong>довгострокова стратегія</strong> (Принцип 8), яка дозволить незалежно масштабувати та розвивати окремі компоненти (чати, дзвінки, ШІ, платежи), підвищуючи загальну <strong>надійність та гнучкість</strong> системи (Принцип 3, 11).",
        "interaction": "Взаємодія між компонентами відбуватиметься через <strong>GraphQL API</strong> (синхронно) та <strong>Kafka</strong> (асинхронно), використовуючи <strong>Apollo Federation</strong> (у майбутньому) для побудови єдиної схеми API з кількох мікросервісів."
      },
      "projectStatus": {
        "title": "Статус Проекту: Поточний Етап (MVP)",
        "content": "На даний момент проект знаходиться на етапі активної розробки <strong>MVP</strong> (згідно з <a href=\"https://www.notion.so/MVP-11a2a21315e54eb3b3c90171b4c7493d?pvs=4\" target=\"_blank\" rel=\"noopener noreferrer\">Інструкцією з Вимог до MVP</a>). Ми зосереджені на завершенні основної функціональності обміну повідомленнями, обробки файлів, створення груп/каналів та базових налаштувань, одночасно зміцнюючи <strong>технічний фундамент</strong> (Принцип 8) та впроваджуючи процеси <strong>безперервного навчання</strong> та <strong>Кайдзен</strong> у нашу щоденну роботу.",
        "progress": "Прогрес документується через завдання, код у репозиторії та відеозаписи, які демонструють наш шлях та <strong>процес створення</strong> (Принцип 1)."
      },
      "gettingStarted": {
        "title": "Початок Роботи (Для Розробників)",
        "intro": "Хочете приєднатися до нас у створенні цього цифрового АКТИВУ? Ось як почати:",
        "steps": [
          "Клонуйте репозиторій:<br/>```bash<br/>git clone <https://github.com/xAI/BrainMessenger.git> # Приклад<br/>cd BrainMessenger<br/>```",
          "Встановіть залежності:<br/>```bash<br/>npm install # Turborepo встановить залежності для всіх пакетів<br/>```",
          "Налаштуйте змінні середовища: Скопіюйте `.env.example` до `.env` та заповніть необхідні дані для інтеграцій (Neon, R2, Firebase тощо). <strong>Не комітьте ваш файл `.env`!</strong><br/>```bash<br/>cp .env.example .env<br/># Заповніть .env<br/>```",
          "Налаштуйте базу даних: Запустіть локальний PostgreSQL або використовуйте екземпляр Neon, потім застосуйте міграції Prisma.<br/>```bash<br/>cd backend<br/>npx prisma migrate dev --name initial_setup # Або npx prisma migrate deploy для продакшену<br/>cd ..<br/>```",
          "Запустіть сервіси в режимі розробки:<br/>```bash<br/>turbo run dev # Це запустить dev-сервери бекенду та фронтенду<br/># Або перейдіть до конкретних пакетів та запустіть їхні dev-скрипти:<br/># cd backend && npm run start:dev<br/># cd packages/web && npm run dev<br/># cd packages/mobile-desktop && npm run android / npm run windows<br/>```"
        ],
        "outro": "Більш детальні інструкції щодо локального налаштування та розробки можна знайти в <a href=\"link_to_development_guide_doc\" target=\"_blank\" rel=\"noopener noreferrer\">Посібнику з Розробки</a>."
      },
      "documentationSystem": {
        "title": "Документація: Наша Система Знань",
        "intro": "Цей README надає загальний огляд. Вся детальна інформація про проект міститься в нашій <strong>комплексній системі документації</strong>. Вивчення цих документів є частиною процесу <strong>навчання</strong> (Принцип 1) та розуміння <strong>системи</strong> (Принцип 9):",
        "links": [
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація Вимог</strong></a>: Що ми будуємо (функціональні та нефункціональні вимоги).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocDevIn.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Розробки</strong></a>: Як ми пишемо код (структура, стандарти, інструменти, процес CI/CD).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocTech.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Технічна Документація</strong></a>: Загальний огляд архітектури та стеку.",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocSpec.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Специфікація API</strong></a>: Як взаємодіють компоненти (опис GraphQL API).",
          "<a href=\"docs/AllRequirements/Docs/Dev/DocInt.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація Інтеграцій</strong></a>: Як ми використовуємо зовнішні сервіси (Neon, R2, Firebase, Stripe тощо) як <strong>важелі</strong>.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocSecurity.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Безпеки</strong></a>: Як ми захищаємо АКТИВ та дані (принципи, методи, інструменти, процес).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocPer.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Продуктивності</strong></a>: Як ми робимо систему швидкою (метрики, техніки, інструменти оптимізації).",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMonLog.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Моніторингу та Логування</strong></a>: Як ми бачимо стан системи (метрики, логи, сповіщення).",
          "<a href=\"docs/AllRequirements/Docs/Design/Design/DocUI.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Документація UI</strong></a>: Як виглядає додаток і чому (макети, компоненти, принципи дизайну).",
          "<a href=\"docs/AllRequirements/Docs/Sound/DocSound.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Аудіо</strong></a>: Як аудіо використовується для покращення UX.",
          "<a href=\"docs/AllRequirements/Docs/Support/DocSupport.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Підтримки та Обслуговування</strong></a>: Як ми підтримуємо систему та користувачів після релізу.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocSpecError.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Специфікація Помилок</strong></a>: Як ми обробляємо та повідомляємо про помилки.",
          "<a href=\"docs/AllRequirements/Docs/Testing/DocTesting.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Посібник з Тестування</strong></a>: Як ми перевіряємо якість та надійність.",
          "<a href=\"docs/AllRequirements/Docs/Infrastructure/DocMigrationMicro.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>План Міграції Мікросервісів</strong></a>: Наша довгострокова стратегія архітектурної еволюції.",
          "<a href=\"docs/AllRequirements/Docs/Planning/DocReq.md\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>Інструкція з Вимог до MVP</strong></a>: Детальний аналіз вимог до MVP та статус реалізації)."
        ]
      },
      "contribution": {
        "title": "Внесок",
        "content": "Ми вітаємо внески у створення цього цифрового АКТИВУ! Якщо у вас є ідеї, пропозиції або ви хочете допомогти з кодом, будь ласка, зверніться до <a href=\"CONTRIBUTING.md\" target=\"_blank\" rel=\"noopener noreferrer\">Посібника з Внесків</a> (якщо доступний)."
      }
    },
    "design": {
      "title": "Документація Дизайна BrainMessenger",
      "subtitle": "Система Качества и Ценности",
      "section1": {
        "title": "1. Введение: Дизайн как Фундамент Ценности",
        "name": "BrainMessenger Design System",
        "description": "Эта дизайн-система определяет визуальные и функциональные стандарты для интерфейса BrainMessenger. Наша цель — создать интерфейс, который не просто выглядит хорошо, но и является <strong>интуитивно понятным, эффективным и доступным</strong> (Принцип 2: Создание Ценности), опираясь на принципы <strong>качества > количества</strong> (Принцип 3) и <strong>прагматизма</strong> (Принцип 12) в выборе решений.",
        "goal": "Обеспечить <strong>единообразие, надежность и позитивный пользовательский опыт</strong> на всех платформах (Windows, Android, веб), делая BrainMessenger <strong>полезным АКТИВОМ</strong> (Принцип 10) для пользователей.",
        "principles_title": "Принципы, которыми руководствуется дизайн:",
        "principles": [
          "<strong>Создание Ценности (Принцип 2):</strong> Дизайн должен быть функциональным и решать задачи пользователя максимально удобно и эффективно.",
          "<strong>Качество > Количество (Принцип 3):</strong> Фокус на отточенности ключевых элементов, а не на множестве непродуманных деталей. Дизайн должен быть <strong>надежным</strong> и <strong>продуманным</strong>.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор дизайнерских решений, реализуемых с учетом технических ограничений (например, оптимизация анимаций).",
          "<strong>Целостность (Принцип 7):</strong> Визуальная и функциональная целостность на всех платформах.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Внимание к доступности (WCAG), чтобы дизайн не создавал излишней нагрузки (зрительной, когнитивной) на пользователя."
        ]
      },
      "section2": {
        "title": "2. Цветовая палитра: Визуальный язык BrainMessenger",
        "intro": "Цвета разделены для Light и Dark режимов, поддерживая переключение темы (функция \"Night Mode\"). Все цвета заданы в HEX.",
        "light_mode_title": "2.1. Light Mode",
        "light_mode_table": [
          ["Категория", "Цвет (HEX)", "Назначение"],
          ["<strong>Primary Gradient</strong>", "`#A7F43A` → `#00C853`", "Основной градиент для акцентных элементов (кнопки \"Get Started\", иконки)"],
          ["<strong>Accent</strong>", "`#FF6347`", "Акцентные элементы (ошибки, важные сообщения)"],
          ["<strong>Secondary", "`#00BFFF`", "Второстепенные кнопки, ссылки"],
          ["<strong>Success</strong>", "`#96C93D`", "Подтверждение, успешные действия"],
          ["<strong>Background</strong>", "`#1A1A1A`", "Основной фон"],
          ["<strong>Surface</strong>", "`#333333`", "Карточки, панели, фоны сообщений"],
          ["<strong>Text Primary</strong>", "`#FFFFFF`", "Основной текст"],
          ["<strong>Text Secondary", "`#D9E8D9`", "Вторичный текст, подсказки"],
          ["<strong>Disabled</strong>", "`#4D4D4D`", "Неактивные элементы"],
          ["<strong>Border</strong>", "`#B0B0B0`", "Границы, разделители"]
        ],
        "premium_colors_title": "2.3. Цвета Премиум-Функций (Визуальное выделение Ценности)",
        "premium_colors": [
          "<strong>Premium Accent:</strong> `#FFD600` (Золотой)",
          "<strong>Premium Secondary:</strong> `#2196F3` (Синий)",
          "Используются для визуального выделения премиум-функций (например, в анимациях нейронных связей, специальных элементах UI), подчеркивая их <strong>дополнительную ценность</strong> (Принцип 2, 10)."
        ],
        "color_application_title": "2.4. Применение Цветов (Примеры)",
        "color_application": [
          {
            "title": "Welcome Screen (со скриншота):",
            "items": [
              "Фон: `#1A1A1A` (Dark Mode).",
              "Кнопка \"Get Started\": Градиент `#F2F047` → `#1ED94F`.",
              "Иконка чата: `#F2F047` (обводка) с белым символом внутри.",
            "Текст: `#FFFFFF` (Welcome to Brain Messenger), `#D9E8D9` (подсказка)."
            ]
          },
          {
            "title": "Переключение темы:",
            "items": [
              "Реализовано через глобальный флаг `themeMode` (`Light`/`Dark`).",
              "Пример в React Native:\n```jsx\nimport { useColorScheme } from 'react-native';\nconst themeMode = useColorScheme() === 'dark' ? 'Dark' : 'Light';\nconst backgroundColor = themeMode === 'Dark' ? '#1A1A1A' : '#FFFFFF'; // Пример выбора фона\n```"
            ]
          }
        ],
        "usage_recommendations_title": "2.5. Рекомендации по Использованию Цветов",
        "usage_recommendations": [
          "<strong>Градиенты:</strong> Используйте `#A7F43A` → `#00C853` или `#F2F047` → `#1ED94F` (в зависимости от темы) для ключевых действий и акцентных элементов, привлекающих внимание к <strong>ценности</strong> (Принцип 2).",
          "<strong>Темная тема:</strong> Используйте `#1A1A1A` или `#212121` как основной фон для снижения нагрузки на глаза (связь с Принципом 5: Здоров'я).",
          "<strong>Контраст:</strong> Всегда проверяйте контрастность текста и элементов для обеспечения <strong>доступности</strong> (WCAG 2.1 AA) и соответствия Принципу 7 (Целостность). Используйте инструменты вроде WebAIM Contrast Checker."
        ]
      },
      "section3": {
        "title": "3. Типографика: Читабельность как Основа Эффективности",
        "intro": "Выбор шрифта и его применение базируются на обеспечении максимальной читабельности и доступности, что является критически важным для эффективного усвоения информации и снижения когнитивной нагрузки (связь с Принципом 5: Здоров'я и Принципом 2: Ценность).",
        "primary_font_title": "3.1. Основной шрифт",
        "primary_font": [
          "<strong>Семейство:</strong> Roboto (Google Fonts)",
          "<strong>Запасной:</strong> Sans-serif",
          "<strong>Причина:</strong> Высокая читабельность на разных размерах экрана, широкая поддержка символов (мультиязычность), открытая лицензия и доступность."
        ],
        "sizes_styles_title": "3.2. Размеры и стили (Шкала для Иерархии)",
        "sizes_styles_table": [
          ["Уровень", "Размер", "Начертание", "Использование"],
          ["H1 (Заголовок)", "24px", "Bold", "Основные заголовки экранов (например, \"Чаты\")"],
          ["H2 (Подзаголовок)", "18px", "Medium", "Второстепенные заголовки, названия групп"],
          ["Body", "16px", "Regular", "Основной текст сообщений, список чатов"],
          ["Caption", "14px", "Regular", "Подписи под фото, время сообщений, дрібний текст"],
          ["Button", "16px", "Medium", "Текст кнопок дій"]
        ],
        "notes_title": "Примітки:",
        "notes": [
          "<strong>Висота рядка (Line Height):</strong> Мінімум 1.5 для основного тексту для покращення читабельності.",
          "<strong>Кастомизация (Принцип 2):</strong> Пользователь может выбрать альтернативный шрифт в настройках (например, Open Sans) для адаптации под свои предпочтения.",
          "<strong>Доступность:</strong> Соблюдение контраста и минимального размера шрифта для соответствия WCAG."
        ]
      },
      "section4": {
        "title": "4. Анімації: Оптимізація та Сенс (Принцип 12: Прагматизм)",
        "intro": "Анімації в BrainMessenger використовуються для покращення користувацького досвіду, надання візуального зворотного зв'язку та надання інтерфейсу жвавості. Однак вони мають бути <strong>прагматичними, оптимізованими</strong> (<2 ГБ RAM), і <strong>не створювати зайвого навантаження</strong> (зв'язок з Принципом 5: Здоров'я).",
        "principles_title": "4.1. Принципи Анімацій",
        "principles": [
          "<strong>Смысл:</strong> Каждая анимация должна иметь четкую цель – объяснить переход, привлечь внимание к важному, подтвердить действие.",
          "<strong>Плавность:</strong> Использование `ease-in-out` или `ease-out` для натурального движения.",
          "<strong>Оптимизация:</strong> Анимации не должны замедлять интерфейс или споживать много ресурсов. Тривалість підібрана для балансу между плавностью и скоростью.",
          "<strong>Доступность:</strong> Избегание слишком быстрых или мигающих анимаций, которые могут вызвать дискомфорт или приступы у чувствительных пользователей."
        ],
        "list_title": "4.2. Список Анімацій (Примеры)",
        "list_table": [
          ["Название", "Описание", "Триггер", "Параметры", "Связь с Принципами", "Кольоры (Light/Dark)"],
          ["Переключение слайдов", "Сдвиг слайдов (Welcome Screen)", "Свайп/клик по стрелке", "0.3 сек, slide left/right", "P2 (Онбординг)", "#96C93D / #96C93D"],
          ["Открытие чата", "Чат появляется снизу вверх", "Клик по чату в списке", "0.3 сек, ease-in-out", "P2 (Навигация)", "#00BFFF / #00BFFF"],
          ["Нажатие кнопки", "Визуальный фидбек при клике (уменьшение)", "Клик по кнопке", "0.2 сек, scale", "P2 (Фидбек)", "Градиент #F2F047→#1ED94F"],
          ["Отправка сообщения", "Сообщение появляется с плавным появлением", "Клик \"Отправить\"", "0.3 сек, fade-in", "P2 (Фидбек)", "#96C93D / #96C93D"],
          ["Переход между экранами", "Сдвиг экрана вправо/влево (базовая навигация)", "Навигация", "0.3 сек, slide", "P2 (Навигация)", "#B0B0B0 / #4D4D4D"],
          ["Анимация иконок (Morph)", "Преобразование иконки (например, mute → unmute)", "Клик (переключение состояния)", "0.4 сек, morph", "P2 (Состояние)", "#FF6347 / #FF6347"],
          ["Волны при нажатии (Ripple)", "Радиальные волны от точки нажатия (фидбек)", "Клик по кнопке/элементу", "0.3 сек, ripple", "P2 (Фидбек)", "#F2F047 / #F2F047"],
          ["Глитч-эффект (Premium)", "Искажение текста для премиум (визуализация)", "Активация подписки", "0.2 сек, glitch", "P2, P10 (Выделение)", "#FF6347 / #FF6347"],
          ["Нейронные связи (Premium)", "Пульсирующие линии (визуализация Актива)", "Премиум-экран", "0.5 сек, pulse", "P2, P10 (Выделение)", "#96C93D / #96C93D"]
        ],
        "implementation_examples_title": "4.3. Примеры Реализации (Фрагменты кода)",
        "css_ripple_title": "CSS для Ripple-эффекта:",
        "css_ripple_code": ".ripple {\\n  background: linear-gradient(45deg, #F2F047, #1ED94F); /* Або інші кольори/градієнт */\\n  border-radius: 50%;\\n  animation: ripple 0.3s ease-out;\\n}\\n@keyframes ripple {\\n  to { transform: scale(2); opacity: 0; }\\n}",
        "rn_icon_title": "React Native для анімованої іконки:",
        "rn_icon_code": "import Animated from 'react-native-reanimated'; // Пример библиотеки\\nimport Icon from 'react-native-vector-icons/MaterialIcons'; // Пример библиотеки\\n\\nconst color = themeMode === 'Dark' ? '#FFFFFF' : '#333333';\\n// Створення анімованого компонента Icon\\nconst AnimatedIcon = Animated.createAnimatedComponent(Icon);\\n\\n// Пример использования с анимацией scale (припускаючи, что 'scale' - это Animated.Value)\\n<AnimatedIcon name=\\\"volume-up\\\" color={color} style={{ transform: [{ scale: scale }] }} />"
      },
      "section5": {
        "title": "5. Вирівнювання та Сітка: Структура та Порядок (Принцип 9: Система)",
        "intro": "Використання послідовної системи вирівнювання та модульної сітки — это основа для создания <strong>системного, легко подтримуваемого и визуально гармоничного</strong> интерфейса (Принцип 9: Система).",
        "base_grid": "<strong>Базовая Сітка:</strong> 8px (базовый шаг для определения размеров элементов, отступов, интервалов). Все значения должны быть кратны 8 (или 4 для очень мелких элементов).",
        "alignment_title": "<strong>Вирівнювання:</strong>",
        "alignment": [
          "Используется принцип <strong>визуальной иерархии</strong>: более важные элементы располагаются выше или визуально доминируют.",
          "<strong>Вертикальный поток:</strong> Контент на экранах организуется сверху вниз: Заголовок → Поле ввода → Кнопка действия.",
          "<strong>Горизонтальное выравнивание:</strong> Элементы в контейнерах выравниваются по левому краю (для LTR) или правому краю (для RTL), если нет необходимости в центрировании (например, заголовки в шапке).",
          "<strong>Отступы (Padding/Margin):</strong> Используются значения из шкалы, кратной 8px (8, 16, 24, 32, 40, 48 px и т.д.) для создания четких интервалов между элементами и группами элементов."
        ],
        "adaptability_title": "<strong>Адаптивність та Респонсивність:</strong>",
        "adaptability": [
          "Дизайн адаптируется под различные размеры экрана для обеспечения <strong>ценности</strong> (Принцип 2) на любом устройстве.",
          "<strong>Мобільні пристрої:</strong> 320px–767px (Обычно одноколоночный макет).",
          "<strong>Планшеты:</strong> 768px–1023px (Возможно, двухколоночный макет, боковые панели).",
          "<strong>Десктоп:</strong> 1024px+ (Широкий макет, многоколоночный дизайн, боковые панели)."
        ]
      },
      "section6": {
        "title": "6. Принципи Доступності (WCAG 2.1 AA): Дизайн для Всіх (Принцип 5: Здоров'я, Принцип 7: Цілісність)",
        "intro": "<strong>Доступність — это не опция, а фундаментальное требование</strong> (схоже с Принципом 5: Здоров'я как Фундамент) для создания <strong>целостного</strong> (Принцип 7) и <strong>ценного</strong> (Принцип 2) продукта, которым могут пользоваться все, независимо от их способностей или используемых технологий. Мы стремимся соответствовать уровню WCAG 2.1 AA.",
        "principles": [
          "<strong>Контрастность Кольорів:</strong> Текстовые элементы должны иметь минимальный контраст 4.5:1 (для обычного текста) и 3:1 (для крупного текста или иконок) по отношению к фону. Это проверяется для обеих тем (Light/Dark).",
          "<strong>Навігація з Клавіатури:</strong> Все интерактивные элементы (кнопки, посилання, поля ввода) должны быть доступны для навигации с помощью клавиатуры (Tab, Shift+Tab) и активации (Enter, Space).",
          "<strong>Підтримка Екранних Читалок (Screen Readers):</strong> Использование семантической разметки (HTML) и ARIA-атрибутов для предоставления контекста и информации пользователям экранных читалок (например, описания для иконок, состояния элементов).",
          "<strong>Візуальний Индикатор Фокуса:</strong> Для пользователей клавиатуры должен быть четкий и видимый индикатор текущего сфокусированного элемента (например, синяя обводка `#007BFF`).",
          "<strong>Обробка Помилок:</strong> Сообщения об ошибках должны быть четкими, понятными и легко определяемыми пользователями, включая пользователей экранных читалок.",
          "<strong>Підтримка RTL (Справа Налево):</strong> Дизайн адаптируется для языков с направлением письма справа налево (например, арабский), включая зеркальное отображение макета, иконок и текста (см. DocLocIn.md)."
        ]
      },
      "section7": {
        "title": "7. Примітки та Рекомендації",
        "notes": [
          "<strong>Кастомизация Пользователем:</strong> Помните, что некоторые аспекты дизайна (цвета чатов, шрифты) пользователь может изменять в настройках. Дизайн системы должен учитывать эту гибкость.",
          "<strong>Тестирование на Реальных Устройствах:</strong> Все компоненты дизайна необходимо тестировать на разнообразных устройствах, с различными разрешениями экрана и в разных условиях освещения, чтобы убедиться в их эффективности и доступности.",
          "<strong>Живая Документация:</strong> Эта дизайн-система — живой документ. Она будет дополняться новыми компонентами, шаблонами и рекомендациями по мере развития продукта, отражая принципы <strong>непрерывного совершенствования</strong> (Принцип 1) и <strong>системного подхода</strong> (Принцип 9).",
          "<strong>Дизайн как часть Процесса Кайдзен:</strong> Дизайн-решения анализируются и улучшаются на основе обратной связи и реального использования, интегрируясь в общий процесс Кайдзен (Принцип 9, 14)."
        ]
      }
    },
    "localizationGuide": {
      "title": "Руководство по Локализации BrainMessenger",
      "subtitle": "Доступность и Масштабирование",
      "section1": {
        "title": "1. Введение: Расширение Ценности через Доступность",
        "name": "BrainMessenger Design System",
        "description": "Это руководство описывает процесс локализации BrainMessenger — ключевой шаг для обеспечения доступности и ценности (Принцип 2) продукта для широкой аудитории по всему миру. Мы рассматриваем локализацию не просто как перевод строк, а как систематический процесс (Принцип 9) адаптации интерфейса и контента, который позволит нам масштабировать наше влияние (Принцип 2, 8).",
        "goal": "Сделать BrainMessenger понятным и удобным для пользователей из разных культур, начиная с базового набора языков и создавая надежную систему (Принцип 9) для легкого добавления новых в будущем.",
        "current_status": "Базовая поддержка английского языка (MVP). Идет планирование и подготовка к добавлению новых языков в рамках текущих этапов разработки (см. Дорожную карту).",
        "principles_title": "Принципы, которыми руководствуется локализация:",
        "principles": [
          "Создание Ценности (Принцип 2): Локализация напрямую повышает ценность продукта для неанглоязычных пользователей.",
          "Система и Оптимизация (Принцип 9): Процесс локализации строится как четкая, повторяемая система для эффективности.",
          "Прагматизм и Реализм (Принцип 12): Выбор начального набора языков основывается на потенциальном охвате и ресурсах.",
          "Внешняя Экспертиза и Обратная Связь (Принцип 14): Привлечение профессиональных переводчиков и сбор обратной связи от пользователей на разных языках."
        ]
      },
      "section2": {
        "title": "2. Цели Локализации",
        "goals": [
          "Обеспечить поддержку минимум 5 ключевых языков (Английский, Испанский, Французский, Русский, Арабский) для старта MVP — (Требование NFR-11, соответствующее Принципу 12: Прагматизм).",
          "Реализовать адаптацию пользовательского интерфейса для языков с направлением письма справа налево (RTL), таких как арабский (Принцип 2: Доступность).",
          "Поддерживать единообразие терминологии и стиля во всех переводах, используя централизованные инструменты (Принцип 9: Система).",
          "Создать эффективный и простой процесс добавления новых языков по мере роста базы пользователей и поступления запросов (Принцип 9: Масштабирование, Принцип 12: Прагматизм, Принцип 14: Обратная связь)."
        ]
      },
      "section3": {
        "title": "3. Инструменты и Технологии: Надежный Фундамент (Принцип 8, 9)",
        "intro": "Выбор инструментов основан на прагматизме (Принцип 12), надежности и поддержке системного подхода (Принцип 9).",
        "tools_table": [
          ["Инструмент", "Назначение", "Установка/Конфигурация"],
          ["i18next", "Основная библиотека для управления переводами в Frontend (React Native). Поддерживает интерполяцию, контексты.", "npm install i18next react-i18next"],
          ["react-intl", "Библиотека для локализованного форматирования дат, чисел, валют в Frontend.", "npm install react-intl"],
          ["Transifex", "Профессиональная платформа для управления переводами, привлечения переводчиков и обеспечения качества перевода.", "Регистрация на transifex.com"],
          ["rtlcss", "Утилита для автоматической трансформации CSS-стилей для поддержки RTL-языков.", "npm install -g rtlcss (глобально) или npm install rtlcss --save-dev"],
          ["JSON файлы", "Формат хранения переводов.", "Стандартный."]
        ]
      },
      "section4": {
        "title": "4. Структура Файлов Переводов: Порядок в Системе (Принцип 9)",
        "intro": "Переводы организованы в четкой файловой структуре для удобства управления (Принцип 9: Система).",
        "location_title": "4.1. Расположение",
        "location_content": "Файлы переводов хранятся в директории locales внутри frontend/src:\\n\\nfrontend/\\n├── src/\\n│ ├── locales/\\n│ │ ├── en.json # Английский (базовый)\\n│ │ ├── es.json # Испанский\\n│ │ ├── fr.json # Французский\\n│ │ ├── ru.json # Русский\\n│ │ ├── ar.json # Арабский (пример RTL)\\n│ └── index.ts # Конфигурация i18next",
        "format_title": "4.2. Формат JSON: Контекст и Гибкость",
        "format_content": "Ключи: Используется camelCase. Ключи должны быть описательными и отражать контекст использования строки (например, sendButton вместо просто send).\\n\\nЗначения: Содержат переводимый текст. Поддерживается интерполяция для вставки динамических данных (например, имена пользователей).",
        "format_example": "Пример en.json:\\n\\n```json\\n{\\n  \\\"welcomeTitle\\\": \\\"Welcome to BrainMessenger!\\\",\\n  \\\"sendButton\\\": \\\"Send\\\",\\n  \\\"errors\\\": {\\n    \\\"unauthorized\\\": \\\"Please log in again to continue.\\\",\\n    \\\"notFound\\\": \\\"The requested item could not be found.\\\"\\n  },\\n  \\\"chat\\\": {\\n    \\\"newMessageNotification\\\": \\\"New message from {{name}}\\\",\\n    \\\"unreadCount\\\": \\\"{{count}} unread messages\\\"\\n  },\\n  \\\"settings\\\": {\\n    \\\"language\\\": \\\"Language\\\",\\n    \\\"theme\\\": \\\"Theme\\\"\\n  }\\n}\\n```",
        "rtl_flag_title": "4.3. RTL-флаг: Адаптация Интерфейса",
        "rtl_flag_content": "Для языков с направлением справа налево в начало соответствующего JSON-файла добавляется метаданные для индикации:",
        "rtl_flag_example": "```json\\n{\\n  \\\"rtl\\\": true,\\n  \\\"welcomeTitle\\\": \\\"مرحبًا بك في BrainMessenger!\\\"\\n  // ... остальные переводы\\n}\\n```\\n\\nЭтот флаг используется Frontend-приложением для соответствующей адаптации стилей и макета."
      },
      "section5": {
        "title": "5. Настройка Локализации: Интеграция в Систему (Принцип 9)",
        "intro": "Локализация интегрируется как в Frontend (для отображения переведенного UI), так и в Backend (для возврата локализованных ошибок или уведомлений).",
        "frontend_title": "5.1. Frontend (React Native): Использование i18next",
        "frontend_init_title": "Инициализация i18next:",
        "frontend_init_code": "В главном файле приложения или файла конфигурации (frontend/src/index.ts или подобном):\\n\\n```jsx\\nimport i18n from 'i18next'\\nimport { initReactI18next } from 'react-i18next'\\n\\n// Импорт всех файлов локалей\\nimport en from './locales/en.json'\\nimport es from './locales/es.json'\\nimport fr from './locales/fr.json'\\nimport ru from './locales/ru.json'\\nimport ar from './locales/ar.json'\\n\\n// Определение ресурсов\\nconst resources = {\\n  en: { translation: en },\\n  es: { translation: es },\\n  fr: { translation: fr },\\n  ru: { translation: ru },\\n  ar: { translation: ar },\\n};\\n\\ni18n\\n  .use(initReactI18next) // Подключение react-i18next\\n  .init({\\n    resources,\\n    lng: 'en', // Язык по умолчанию при первом запуске (может определяться по системным настройкам или выбору пользователя)\\n    fallbackLng: 'en', // Резервный язык, если текущий перевод отсутствует\\n    interpolation: {\\n      escapeValue: false // Позволяет использовать HTML теги в переводах (осторожно!)\\n    }\\n  });\\n\\nexport default i18n;\\n```",
        "frontend_usage_title": "Использование перевода в компонентах:",
        "frontend_usage_code": "Используйте хук useTranslation для доступа к функции t и объекту i18n.\\n\\n```jsx\\nimport { useTranslation } from 'react-i18next';\\nimport { Text, Button, View } from 'react-native';\\n\\nconst WelcomeScreen = () => {\\n  const { t, i18n } = useTranslation(); // Получаем функцию t и объект i18n\\n\\n  return (\\n    <View>\\n      {/* Использование простого перевода */}\\n      <Text>{t('welcomeTitle')}</Text>\\n      \\n      {/* Использование перевода с интерполяцией */}\\n      {/* Предполагается, что где-то есть состояние unreadCount */}\\n      <Text>{t('chat.unreadCount', { count: 5 })}</Text> \\n\\n      {/* Использование перевода для текста кнопки */}\\n      <Button title={t('sendButton')} onPress={sendMessage} />\\n      \\n      {/* Пример смены языка */}\\n      <Button title={t('settings.language')} onPress={() => i18n.changeLanguage('ar')} />\\n    </View>\\n  );\\n};\\n```",
        "frontend_change_title": "Смена языка:",
        "frontend_change_content": "Язык меняется вызовом i18n.changeLanguage('код_языка'). Обычно это делается в настройках пользователя.",
        "backend_title": "5.2. Backend (NestJS): Локализация Ошибок и Уведомлений",
        "backend_intro": "Backend может возвращать локализованные сообщения об ошибках или уведомления, опираясь на язык, переданный Frontend (например, в заголовке Accept-Language или настройках пользователя).",
        "backend_code": "Использование локализованных сообщений при выбрасывании ошибок:\\n\\n```typescript\\nimport { HttpException, HttpStatus }n from '@nestjs/common';\\nimport { t } from 'i18next'; // Предполагается, что i18next инициализирован и в Backend\\n\\n// В сервисе или контроллере\\nif (!user) {\\n  // Определяем язык пользователя (например, из request.headers['accept-language'])\\n  const userLang = determineUserLanguage(request); \\n  throw new HttpException(t('errors.unauthorized', { lng: userLang }), HttpStatus.UNAUTHORIZED);\\n}\\n```",
        "backend_note": "Локаль пользователя определяется из заголовка Accept-Language (стандартный подход) или сохраняется в профиле пользователя в базе данных после его выбора в настройках приложения.",
        "rtl_adaptation_title": "5.3. RTL-адаптация (Справа Налево): Зеркальное Отображение Системы",
        "rtl_adaptation_intro": "Для языков с RTL (арабский, иврит и др.) необходимо зеркально отобразить макет и некоторые элементы интерфейса.",
        "rtl_css_title": "Стили (CSS/CSS-in-JS):",
        "rtl_css_code": "Используйте rtlcss в процессе сборки или условные стили в коде. rtlcss автоматически преобразует свойства вроде margin-left, padding-right, text-align: left и т.п. в их RTL-эквиваленты (margin-right, padding-left, text-align: right).\\n\\n```css\\n/* Исходный CSS для LTR */\\n.message-bubble {\\n  margin-left: 10px;\\n  text-align: left;\\n}\\n/* После обработки rtlcss для RTL */\\n.message-bubble {\\n  margin-right: 10px;\\n  text-align: right;\\n}\\n```",
        "rtl_rn_title": "React Native:",
        "rtl_rn_code": "React-Native имеет встроенную поддержку RTL через I18nManager.\\n\\n```jsx\\nimport { I18nManager } from 'react-native';\\nimport i18n from './index'; // Ваш файл инициализации i18next\\n\\n// В главном файле приложения, перед рендером\\nconst isRTL = i18n.language === 'ar' || i18n.language === 'he'; // Проверяем, является ли текущий язык RTL\\n\\n// ForceRTL может потребовать перезагрузки приложения для полной силы\\nif (isRTL !== I18nManager.isRTL) {\\n  I18nManager.forceRTL(isRTL);\\n  // Optional: Restart the app to apply RTL layout fully\\n  // RNRestart.Restart(); \\n}\\n\\n// Некоторые стили могут требовать ручной адаптации, если auto-conversion недостаточно\\nconst containerStyle = {\\n  flexDirection: isRTL ? 'row-reverse' : 'row',\\n  textAlign: isRTL ? 'right' : 'left',\\n};\\n```",
        "rtl_icons_title": "Иконки:",
        "rtl_icons_content": "Некоторые иконки (например, стрелки \"назад\", \"далее\") должны быть зеркально отображены для RTL. Это можно делать условно в коде или использовать RTL-ready наборы иконок."
      },
      "section6": {
        "title": "6. Процесс Добавления Нового Языка: Масштабируемая Система (Принцип 9)",
        "intro": "Процесс добавления нового языка построен как четкая, повторяемая последовательность действий для обеспечения эффективности (Принцип 9).",
        "file_title": "Создание базового файла перевода:",
        "file_content": "Скопируйте актуальный en.json (или другой наиболее полный файл) в frontend/src/locales/<code>.json, где <code> — двухбуквенный код нового языка (например, de.json для немецкого).\\nДобавьте rtl: true в начало файла, если новый язык RTL.",
        "transifex_title": "Загрузка на платформу переводов (Transifex):",
        "transifex_content": "Загрузите новый файл <code>.json в проект BrainMessenger на Transifex. Система автоматически определит, какие строки нуждаются в переводе.",
        "process_title": "Организация процесса перевода:",
        "process_content": "Назначьте переводчиков (профессионалов или проверенных участников сообщества, Принцип 14) для нового языка в Transifex.\\nОтвечайте на их вопросы по контексту строк.\\nКонтролируйте прогресс перевода в Transifex.",
        "export_title": "Экспорт и Интеграция перевода:",
        "export_content": "После завершения перевода экспортируйте готовый файл <code>.json из Transifex.\\nПоместите его обратно в директорию frontend/src/locales/.\\nИмпортируйте новый ресурс в файле инициализации i18next (frontend/src/index.ts) и добавьте его в объект resources.",
        "ui_title": "Добавление опции выбора языка в UI:",
        "ui_content": "Добавьте новый язык в список доступных языков в разделе \"Настройки\" > \"Язык\".",
        "testing_title": "Тестирование:",
        "testing_intro": "Критически важный шаг (Принцип 3: Качество). Переключите язык в настройках приложения.",
        "testing_scenarios": [
          "Корректность перевода всех строк в UI.",
          "Отсутствие обрезки текста (некоторые языки длиннее английского).",
          "Корректное отображение UI для RTL-языков (зеркальность, выравнивание).",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ]
      },
      "section7": {
        "title": "7. Поддерживаемые Языки (Начальный Список и План)",
        "intro": "Начальный список языков, выбранный по прагматическим соображениям (Принцип 12) и потенциальному охвату.",
        "languages_table": [
          ["Код", "Язык", "Направление", "Статус", "План (Q 2025)"],
          ["en", "Английский", "LTR", "Реализован (Базовый)", "-"],
          ["es", "Испанский", "LTR", "В плане (Q3)", "Q3"],
          ["fr", "Франглийский", "LTR", "В плане (Q3)", "Q3"],
          ["ru", "Русский", "LTR", "В плане (Q3)", "Q3"],
          ["ar", "Арабский", "RTL", "В плане (Q3, требуется RTL)", "Q3"]
        ],
        "expansion_note": "Расширение списка: Новые языки будут добавляться на основе обратной связи (Принцип 14) и анализа потенциальной ценности (Принцип 2) для роста аудитории (например, если >10% запросов о поддержке нового языка)."
      },
      "section8": {
        "title": "8. Рекомендации: Лучшие Практики Локализации",
        "dev_title": "8.1. Для Разработчиков (Пишем Код, Готовый к Миру)",
        "dev_points": [
          "Не хардкодьте строки! Все строки, которые видит пользователь, должны быть вынесены в файлы локализации и использоваться через функцию t('ключ') (Принцип 9: Система).",
          "Используйте интерполяцию для строк с переменными данными (t('chat.newMessageNotification', { name: user.name })), а не конкатенацию строк в коде.",
          "Учитывайте плюрализацию (формы единственного/множественного числа) при работе со счетчиками ({{count}} unread messages). i18next и react-intl поддерживают это.",
          "Используйте react-intl для всех операций с датами, числами, валютами, чтобы их формат был корректным для каждой локали (Принцип 3: Качество, Принцип 2: Ценность).",
          "Тестируйте UI с длинными переводами (например, немецкий, который часто длиннее английского) и RTL-языками, чтобы убедиться, что макет не ломается и текст не обрезается (Принцип 3: Качество)."
        ],
        "design_title": "8.2. Для Дизайнеров (Рисуем Макеты, Гибкие к Языкам)",
        "design_points": [
          "Учитывайте, что текст на других языках может быть на 30% (и более) длиннее английского. Оставляйте достаточно пространства в компонентах.",
          "Проектируйте макеты с учетом зеркального отображения для RTL. Иконки направлений, расположение текста и элементов должны меняться (Принцип 2: Доступность)."
        ],
        "translator_title": "8.3. Для Переводчиков (Создаем Понятный Контент)",
        "translator_points": [
          "Сохраняйте контекст. Одно и то же английское слово может переводиться по-разному в зависимости от того, где оно используется (например, \"Send\" для сообщения или для заявки). Платформы вроде Transifex помогают добавлять контекстные комментарии.",
          "Придерживайтесь последовательной терминологии, используйте глоссарий, если он есть.",
          "Сохраняйте тон приложения (дружелюбный, но профессиональный, особенно в системных сообщениях и ошибках).",
          "Используйте возможности интерполяции и плюрализации в файлах перевода."
        ]
      },
      "section9": {
        "title": "9. Форматирование (Даты, Числа, Валюты): Детали, Создающие Качество (Принцип 3)",
        "intro": "Корректное отображение локализованных данных критически важно для качества (Принцип 3) и удобства (Принцип 2).",
        "dates_title": "Даты и Время:",
        "dates_code": "```jsx\\nimport { FormattedDate, FormattedTime } from 'react-intl';\\n\\n// Отобразит дату в формате, соответствующем текущей локали\\n<FormattedDate value={new Date()} /> // Например, \\\"3/14/2025\\\" (en-US) или \\\"14.3.2025\\\" (de-DE)\\n<FormattedDate value={new Date()} weekday=\\\"long\\\" year=\\\"numeric\\\" month=\\\"long\\\" day=\\\"numeric\\\" /> // \\\"Friday, March 14, 2025\\\"\\n\\n// Отобразит время\\n<FormattedTime value={new Date()} /> // Например, \\\"3:00:00 PM\\\" (en-US) или \\\"15:00:00\\\" (de-DE)\\n```",
        "numbers_title": "Числа и Валюты:",
        "numbers_code": "```jsx\\nimport { FormattedNumber, FormattedCurrency } from 'react-intl';\\n\\n// Отобразит число с локальным разделителем тысяч и десятичным знаком\\n<FormattedNumber value={1234.56} /> // \\\"1,234.56\\\" (en-US) или \\\"1.234,56\\\" (de-DE)\\n\\n// Отобразит число как процент\\n<FormattedNumber value={0.75} style=\\\"percent\\\" /> // \\\"75%\\\"\\n\\n// Отобразит число как валюту (требует кода валюты)\\n<FormattedCurrency value={123.45} currency=\\\"USD\\\" /> // \\\"$123.45\\\" (en-US)\\n```\\n\\nДля работы с react-intl необходимо обернуть ваше приложение в IntlProvider и загрузить соответствующие данные локали (react-intl/locale-data)."
      },
      "section10": {
        "title": "10. Тестирование Локализации: Гарантия Качества (Принцип 3, 9)",
        "intro": "Тестирование — неотъемлемая часть системы обеспечения качества (Принцип 3, 9).",
        "scenarios_title": "Сценарии Тестирования:",
        "scenarios_points": [
          "Переключение языка: Убедитесь, что смена языка в настройках мгновенно (или после перезапуска, если требуется I18nManager) применяет новый перевод и RTL-макет.",
          "Отображение всех строк: Проверьте основные экраны и диалоги, чтобы убедиться, что все видимые пользователю строки переведены.",
          "Длинный текст: Проверьте UI с языками, известными своей длиной (например, немецкий, который часто длиннее английского) и RTL-языками, чтобы убедиться, что текст не обрезается, элементы не накладываются друг на друга.",
          "RTL-интерфейс: Тщательно проверьте UI на арабском (или другом RTL-языке): направление текста, выравнивание элементов, отображение иконок направлений, положение скроллбаров.",
          "Интерполяция и Форматирование: Проверьте экраны, где используются динамические данные (имена, счетчики, даты, числа), убедитесь, что они форматируются правильно для текущей локали.",
          "Локализованные ошибки: Инициируйте различные ошибки (неправильный логин, отсутствие элемента), проверьте, что сообщения об ошибках приходят на выбранном языке."
        ]
      },
      "tools_title": "Инструменты:",
      "tools_points": [
        "Ручное тестирование: Основной метод. Тестирование на реальных устройствах с разными локалями.",
        "Автоматизированные тесты (Cypress/detox): Можно написать тесты, которые проверяют наличие определенных ключей перевода на странице или даже делают скриншоты UI для сравнения LTR/RTL макетов (Принцип 9: Система)."
      ],
      "criteria_title": "Критерии Успеха Тестирования:",
      "criteria_points": [
        "100% пользовательских строк переведены.",
        "Отсутствие обрезки или наложения текста в UI.",
        "Корректное и полное RTL-отображение для соответствующих языков.",
        "Правильное локализованное форматирование дат, чисел, валют."
      ]
    },
    "section11": {
      "title": "11. Примечания",
      "notes": [
        "План: Полная реализация поддержки 5 ключевых языков запланирована на Q3 2025 (см. Дорожную карту), после завершения этапа построения технологического фундамента и начала разработки MVP.",
        "Масштабирование: Система разработана так, чтобы добавление новых языков в будущем было эффективным (Принцип 9). Основные затраты — это сам перевод.",
        "Ограничения: Технические логи, сообщения сервера для отладки не переводятся. Локализация касается только пользовательского интерфейса и сообщений, предназначенных для конечного пользователя."
      ]
    }
  },
  "userGuide": {
    "title": "Посібник Користувача BrainMessenger",
    "subtitle": "Ваш Центр Ефективного Спілкування та Зростання",
    "introduction": {
      "title": "1. Вступ: Ласкаво Просимо до Вашої Системи Взаємодії",
      "p1": "<strong>Ласкаво просимо до BrainMessenger!</strong>",
      "p2": "BrainMessenger — це не просто месенджер, а <strong>ваша особиста система</strong> для безпечного, зручного та <strong>ефективного спілкування та взаємодії</strong> (Принцип 2: Створення Цінності, Принцип 9: Система). Ми створили цей <strong>цифровий АКТИВ</strong> (Принцип 10), щоб <strong>спростити складне</strong> (Маргулан), надавши вам надійний інструмент для зв'язку з іншими людьми та організації вашої комунікації.",
      "p3": "Цей посібник — ваш компас у світі BrainMessenger. Він структурований, щоб ви могли швидко освоїти ключові функції та використовувати додаток максимально <strong>ефективно</strong> (Принцип 9).",
      "p4": "<strong>Для кого:</strong> BrainMessenger розроблений для широкої аудиторії та доступний на всіх основних платформах: iOS (версія 13+), Android (версія 9+), а також у вигляді повноцінної веб-версії для сучасних браузерів (Chrome, Firefox, Safari, Edge). Ми прагнемо до максимальної <strong>доступності</strong> (Принцип 5) для всіх.",
      "p5": "<strong>Як почати:</strong> Найбільш <strong>прагматичний</strong> (Принцип 12) спосіб — встановити додаток з відповідного магазину додатків або відкрити веб-сайт `https://brainmessenger.com`."
    },
    "gettingStarted": {
      "title": "2. Початок Роботи: Перші Кроки в Системі BrainMessenger",
      "p1": "Ваш процес реєстрації та входу розроблений як <strong>проста та безпечна система</strong> (Принцип 9, 5).",
      "registration": {
        "title": "2.1. Реєстрація: Створення Вашого Профілю в Системі",
        "steps": [
          "1. Відкрийте додаток або перейдіть на веб-сайт.",
          "2. Натисніть кнопку <strong>\"Get Started\"</strong> (Зареєструватися) на привітальному екрані.",
          "3. Дотримуйтесь покрокових інструкцій:",
          "<strong>Введіть Email:</strong> Ваша діюча адреса електронної пошти (наприклад, `user@example.com`). Вона буде використовуватися для сповіщень, входу та відновлення доступу. Переконайтеся, що формат email коректний.",
          "<strong>Створіть Пароль:</strong> Придумайте <strong>надійний пароль</strong> (мінімум 8 символів, що включає хоча б одну цифру та один спеціальний символ, наприклад, `MyStrongP@ss!1`). Безпека вашого облікового запису — частина нашого <strong>фундаменту</strong> (Принцип 5, 8).",
          "<strong>Введіть Ім'я:</strong> Ваше відображуване ім'я в BrainMessenger.",
          "<strong>Підтвердіть Email:</strong> Ми надішлемо 8-значний код підтвердження на вказаний email (див. Специфікацію API, DocInt). Перевірте вашу пошту (включаючи папку \"Спам\"). Введіть код у додатку.",
          "4. Натисніть кнопку підтвердження на кожному кроці."
        ],
        "result": "*Результат:* Ваш обліковий запис успішно створено. Ви стаєте частиною <strong>системи BrainMessenger</strong>."
      },
      "login": {
        "title": "2.2. Вхід: Доступ до Вашої Мережі Взаємодії",
        "steps": [
          "1. На привітальному екрані виберіть <strong>\"Log In\"</strong> (Увійти).",
          "2. Введіть зареєстрований email та пароль.",
          "3. Натисніть <strong>\"Log In\"</strong> (Увійти)."
        ],
        "note": "*Примітка:* Якщо у вас увімкнена двофакторна автентифікація (2FA) для додаткової безпеки (див. розділ 3.5), вам потрібно буде ввести додатковий код, отриманий електронною поштою, після введення пароля."
      },
      "logout": {
        "title": "2.3. Вихід: Завершення Поточної Сесії",
        "steps": [
          "1. Відкрийте головне меню (зазвичай іконка \"бургер\" або ваш аватар у верхньому куті).",
          "2. Перейдіть до розділу <strong>\"Settings\"</strong> (Налаштування).",
          "3. Прокрутіть вниз і виберіть <strong>\"Log Out\"</strong> (Вийти).",
          "4. Підтвердіть вашу дію, якщо потрібно."
        ]
      }
    },
    "mainFunctions": {
      "title": "3. Основні Функції: Інструменти для Ефективного Спілкування (Принцип 2)",
      "p1": "BrainMessenger надає набір <strong>інструментів</strong> (Принцип 10) для різних видів комунікації, сфокусованих на наданні вам <strong>цінності</strong> (Принцип 2).",
      "chatsAndMessages": {
        "title": "3.1. Чати та Повідомлення: Ваш Особистий Простір Системи Спілкування",
        "sections": [
          "<strong>Перегляд чатів:</strong> На головному екрані відображається <strong>системно організований</strong> (Принцип 9) список усіх ваших чатів (особисті, групові, канали). Чати з новими повідомленнями завжди зверху.",
          "<strong>Створення нового чату:</strong>",
          "1. Натисніть іконку <strong>\"+\"</strong> (зазвичай у правому верхньому куті).",
          "2. Виберіть <strong>\"New Chat\"</strong> (Новий чат) або \"New Group\" (Нова група), \"New Channel\" (Новий канал).",
          "3. Виберіть контакти або додайте учасників, вкажіть назву (для груп/каналів).",
          "4. Натисніть <strong>\"Create\"</strong> (Створити).",
          "<strong>Надсилання повідомлення:</strong>",
          "1. Відкрийте потрібний чат.",
          "2. Введіть текст у поле введення повідомлення внизу.",
          "3. Натисніть іконку <strong>\"Send\"</strong> (Надіслати).",
          "<strong>Надсилання файлів:</strong>",
          "1. У полі введення повідомлення натисніть на іконку скріпки.",
          "2. Виберіть файл (фото, відео, документ). Максимальний розмір файлу для завантаження — 100 МБ.",
          "3. Натисніть <strong>\"Send\"</strong>. Файли надійно зберігаються в Cloudflare R2 (див. DocInt).",
          "<strong>Пошук по чатах та повідомленнях:</strong> Використовуйте рядок пошуку у верхній частині Головного екрану. Пошук здійснюється швидко та <strong>ефективно</strong> (Принцип 9).",
          "<strong>Архівування чатів:</strong> Щоб прибрати чат з основного списку, не видаляючи його, свайпніть його вліво (на мобільних) або використовуйте контекстне меню та виберіть <strong>\"Archive\"</strong> (Архівувати). Доступ до архіву — через головне меню. Частина <strong>системи організації</strong> вашого робочого простору (Принцип 9)."
        ]
      },
      "calls": {
        "title": "3.2. Дзвінки та Відеодзвінки: Пряма Взаємодія",
        "sections": [
          "<strong>Почати дзвінок:</strong> У відкритому чаті натисніть значок телефону (аудіо) або камери (відео).",
          "<strong>Конференції:</strong> Створіть груповий чат та використовуйте функцію \"Start Call\" (Почати дзвінок).",
          "<strong>Історія дзвінків:</strong> Переглядайте список усіх минулих дзвінків у розділі <strong>\"Calls\"</strong> (Дзвінки) головного меню.",
          "<strong>Налаштування якості:</strong> Під час дзвінка ви можете вибрати якість відео/аудіо (низька, середня, висока) для <strong>прагматичного</strong> (Принцип 12) використання інтернет-трафіку."
        ]
      },
      "filesAndMedia": {
        "title": "3.3. Файли та Медіа: Централізований Доступ до Обміну",
        "sections": [
          "<strong>Перегляд файлів з чату:</strong> У відкритому чаті перейдіть до інформації про чат (клік по назві/аватару в шапці) та виберіть розділ <strong>\"Media\"</strong> (Медіа). Тут зібрані всі файли, якими ви обмінювалися в цьому чаті. Ви можете фільтрувати їх за типом."
        ]
      },
      "contacts": {
        "title": "3.4. Контакти: Управління Вашою Мережею Зв'язків",
        "sections": [
          "<strong>Список контактів:</strong> Доступний у розділі <strong>\"Contacts\"</strong> (Контакти) головного меню.",
          "<strong>Пошук та додавання:</strong> Шукайте існуючих користувачів або додавайте нових за email/телефоном."
        ]
      },
      "settings": {
        "title": "3.5. Налаштування: Адаптація Системи під Себе (Принцип 2)",
        "p1": "Розділ \"Налаштування\" дозволяє персоналізувати BrainMessenger, роблячи його більш <strong>цінним та зручним</strong> саме для вас.",
        "sections": [
          "<strong>Профіль:</strong> Змініть ім'я, фото, email, пароль. Налаштуйте параметри безпеки (наприклад, увімкніть <strong>двофакторну автентифікацію (2FA)</strong> для додаткового захисту облікового запису). Пов'язано з <strong>відповідальністю</strong> (Принцип 6) за безпеку своїх даних.",
          "<strong>Сповіщення:</strong> Налаштуйте типи сповіщень, звуки, вібрацію.",
          "<strong>Зовнішній вигляд (Тема):</strong> Виберіть <strong>\"Light\"</strong> (Світла) або <strong>\"Dark\"</strong> (Темна) тему оформлення. Темна тема може знизити навантаження на очі (зв'язок з Принципом 5: Здоров'я).",
          "<strong>Мова:</strong> Виберіть мову інтерфейсу зі списку доступних мов. Зміни застосовуються швидко. Підтримуються мови з написанням справа наліво (RTL), роблячи додаток <strong>доступним</strong> (Принцип 2, 5) для різних регіонів (див. DocLocIn).",
          "<strong>Налаштування Батареї та Анімації:</strong> Увімкніть або вимкніть анімації інтерфейсу. Це <strong>прагматичне</strong> (Принцип 12) рішення для економії заряду батареї та ресурсів пристрою (Принцип 5).",
          "<strong>Налаштування Чату (Кастомізація):</strong> У кожному чаті ви можете змінити його візуальне оформлення (кольори фону, шрифти), що додає <strong>цінності</strong> (Принцип 2) за рахунок персоналізації."
        ]
      },
      "premiumSubscription": {
        "title": "3.6. Premium-підписка: Додаткові Можливості та Підтримка Розвитку Активу (Принцип 2, 10)",
        "p1": "Premium-підписка надає доступ до розширених функцій, що підвищують <strong>цінність</strong> (Принцип 2) вашого досвіду, і є способом підтримати <strong>довгостроковий розвиток</strong> (Принцип 8) BrainMessenger як <strong>цифрового Активу</strong> (Принцип 10).",
        "sections": [
          "<strong>Переваги:</strong> Ознайомтеся з ексклюзивними функціями Premium у розділі <strong>\"Settings\" → \"Premium\"</strong>.",
          "<strong>Оформлення:</strong> Виберіть тарифний план та оформіть підписку через безпечну платіжну систему (Stripe, див. DocInt).",
          "<strong>Історія платежів:</strong> Переглядайте інформацію про ваші транзакції."
        ]
      }
    },
    "faq": {
      "title": "4. Часто Задавані Питання (FAQ): Швидкі Відповіді Системи Знань",
      "p1": "Цей розділ містить відповіді на типові питання, засновані на нашому <strong>накопиченому досвіді</strong> (Принцип 1, 14).",
      "q1": {
        "question": "З: Що робити, якщо я не отримав код підтвердження під час реєстрації?",
        "answer": "В: Перевірте папку \"Спам\" у вашій електронній пошті. Якщо коду немає, поверніться на екран введення коду та натисніть <strong>\"Resend Code\"</strong> (Надіслати код знову)."
      },
      "q2": {
        "question": "З: Як відновити пароль?",
        "answer": "В: На екрані входу натисніть <strong>\"Forgot Password?\"</strong> (Забули пароль?) та дотримуйтесь інструкцій, надісланих на вашу електронну пошту."
      },
      "q3": {
        "question": "З: Як видалити свій обліковий запис та дані?",
        "answer": "В: Ви можете ініціювати видалення облікового запису в <strong>\"Settings\" → \"Profile\"</strong>, вибравши <strong>\"Delete Account\"</strong> (Видалити обліковий запис). Ваші дані будуть безпечно видалені відповідно до політики конфіденційності (див. DocSecurity)."
      },
      "q4": {
        "question": "З: Чи підтримує BrainMessenger наскрізне шифрування?",
        "answer": "В: Так, безпека та <strong>цілісність</strong> (Принцип 7) ваших даних — наш пріоритет. Усі особисті чати використовують наскрізне шифрування."
      }
    },
    "tips": {
      "title": "5. Корисні Поради: Оптимізація Вашого Досвіду (Принцип 9)",
      "p1": "Кілька порад для більш <strong>ефективного</strong> (Принцип 9) використання BrainMessenger:",
      "sections": [
        "<strong>Використовуйте онбординг:</strong> Перший екран зі слайдером містить корисну інформацію про додаток.",
        "<strong>Оптимізуйте продуктивність на своєму пристрої:</strong> Якщо додаток працює повільно або споживає багато батареї, спробуйте вимкнути анімації в <strong>\"Settings\" → \"Battery & Animations\"</strong>. Це <strong>прагматичний</strong> крок для збереження <strong>здоров'я</strong> вашого пристрою (Принцип 5).",
        "<strong>Підтримуйте порядок у чатах:</strong> Використовуйте функцію архівування для приховування менш актуальних діалогів.",
        "<strong>Вивчайте налаштування:</strong> Досліджуйте всі опції в \"Settings\", щоб повністю адаптувати додаток під себе."
        ]
    },
    "support": {
      "title": "6. Підтримка: Ми Готові Сприяти (Принцип 2, 14)",
      "p1": "Якщо у вас виникли питання або проблеми, будь ласка, зв'яжіться з нами. Ваш <strong>зворотний зв'язок</strong> допомагає нам <strong>покращувати систему</strong> (Принцип 9).",
      "sections": [
        "<strong>Через додаток:</strong> Відкрийте головне меню, виберіть <strong>\"Support\"</strong> (Допомога) → <strong>\"Contact Us\"</strong> (Зв'язатися з нами).",
        "<strong>Електронною поштою:</strong> Ви також можете написати нам безпосередньо на адресу `support@brainmessenger.com`."
      ],
      "p2": "Ми прагнемо відповідати на запити швидко та надати вам максимально корисне <strong>сприяння</strong> (Маргулан)."
    }
  },
  "devGuide": {
    "title": "Руководство по Разработке BrainMessenger",
    "subtitle": "Применение Принципов в Коде",
    "introduction": {
      "title": "1. Введение: Процесс Разработки как Система Совершенствования",
      "description": "Этот документ является вашим путеводителем по процессу разработки BrainMessenger. Мы строим этот проект не хаотично, а как <strong>целостную систему</strong> (Принцип 9), где каждый участник команды (или вы сами) действует в соответствии с <strong>четкими стандартами и принципами</strong>, стремясь к <strong>постоянному совершенствованию</strong> (Принцип 1, 9). Этот процесс напрямую влияет на <strong>качество</strong> (Принцип 3) конечного продукта и его превращение в <strong>ценный АКТИВ</strong> (Принцип 10).",
      "goal": "Обеспечить <strong>единый, эффективный и масштабируемый</strong> процесс разработки, упростить онбординг новых участников и поддерживать высокий уровень <strong>качества кода и архитектуры</strong> на каждом этапе, включая глубокое изучение и применение технологий (как видно по трекеру видео).",
      "audience": "Все, кто пишет код или управляет процессом разработки BrainMessenger (Frontend, Backend, Mobile, Desktop, DevOps разработчики).",
      "principles_title": "Принципы, которыми руководствуется процесс разработки:",
      "principles": [
        "<strong>Система и Оптимизация (Принцип 9):</strong> Структура репозитория, стандарты кодирования, CI/CD, использование инструментов — все направлено на создание эффективной и предсказуемой системы. <strong>Кайдзен</strong> применяется к самому процессу разработки.",
        "<strong>Качество > Количество (Принцип 3):</strong> Приоритет отдается написанию чистого, тестируемого и поддерживаемого кода, даже если это занимает больше времени на старте.",
        "<strong>Постоянное Обучение (Принцип 1):</strong> Процесс разработки включает изучение новых технологий, их прагматичное применение и рефлексию над полученным опытом (как документируется в видео трекере и Кайдзен-часах).",
        "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор инструментов и подходов, подходящих для текущего этапа проекта, без излишней сложности.",
        "<strong>Долгосрочное Мышление (Принцип 8):</strong> Архитектурные решения принимаются с прицелом на будущее масштабирование и поддерживаемость. Код пишется так, чтобы его было легко развивать.",
        "<strong>Ответственность и Проактивность (Принцип 6):</strong> Каждый разработчик несет ответственность за качество своего кода, тесты и активно участвует в улучшении процессов."
      ]
    },
    "repoStructure": {
      "title": "2. Структура Репозитория: Монорепо как Система Организации Кода",
      "description": "Проект организован как <strong>монорепозиторий</strong>, используя <strong>Turborepo</strong> для управления пакетами. Это — сознательный выбор, призванный повысить <strong>эффективность</strong> (Принцип 9) за счет переиспользования кода и <strong>оптимизации</strong> (Принцип 9) процессов сборки и тестирования.",
      "core_title": "<code>core</code>:",
      "core_content": "Содержит код, который является <strong>ядром системы</strong> (Принцип 9) и может быть использован на любой платформе (API-клиент, общие утилиты, бизнес-логика, не связанная с UI/сервером). Переиспользование повышает <strong>эффективность</strong> (Принцип 9) и <strong>согласованность</strong> (Принцип 7).",
      "mobile_desktop_title": "<code>mobile-desktop</code>:",
      "mobile_desktop_content": "Содержит код для <strong>клиентского Актива</strong> (Принцип 10) на мобильных и десктопных платформах.",
      "web_title": "<code>web</code>:",
      "web_content": "Содержит код для <strong>клиентского Актива</strong> на веб-платформе.",
      "backend_title": "<code>backend</code>:",
      "backend_content": "Содержит код <strong>серверной части системы</strong>, обрабатывающей запросы, взаимодействующей с БД и внешними сервисами. Это критически важный <strong>рычаг</strong> (Маргулан) для работы всего приложения.",
      "infrastructure_title": "<code>infrastructure</code>:",
      "infrastructure_content": "Содержит конфигурации для <strong>развертывания системы</strong> (Принцип 9) на облачных ресурсах.",
      "docs_title": "<code>docs</code>:",
      "docs_content": "Содержит <strong>документацию — часть системы знаний</strong> (Принцип 1), необходимую для эффективной работы и онбординга.",
      "turbo_title": "<code>turbo.json</code>:",
      "turbo_content": "Определяет, как Turborepo управляет задачами (сборка, тестирование, линтинг) по всему монорепо, используя <strong>кэширование и параллельное выполнение</strong> для <strong>оптимизации</strong> (Принцип 9) времени разработки."
    },
    "techStack": {
      "title": "3. Технологический Стек: Инструменты для Построения Фундамента (Принцип 8)",
      "intro": "Выбор стека основывается на <strong>прагматизме, надежности и потенциале для долгосрочного развития</strong> (Принцип 8, 12). Мы используем <strong>проверенные технологии</strong>, которые позволяют быстро строить, но при этом закладывать <strong>прочный фундамент</strong> (Принцип 8).",
      "table": [
        ["Компонент", "Технология", "Версия", "Назначение", "Связь с Принципами"],
        ["Frontend: Mobile", "React Native", "0.72+", "Создание UI для Android из единой кодовой базы.", "P9 (Система), P12 (Прагматизм), P2 (Ценность - кроссплатформа)."],
        ["Frontend: Desktop", "React Native for Windows (RNW)", "0.72+", "Создание UI для Windows из единой кодовой базы.", "P9 (Система), P12 (Прагматизм), P2 (Ценность - кроссплатформа)."],
        ["Frontend: Web", "Next.js, Tailwind CSS", "14.x", "Веб-приложение с SSR/SSG для SEO и производительности, утилитарная стилизация.", "P2 (Ценность), P9 (Система - фреймворк), P12 (Прагматизм)."],
        ["Frontend: Общее", "TypeScript", "5.x", "Строгая статическая типизация для повышения <strong>качества и надежности</strong> кода.", "P3 (Качество), P9 (Система - предсказуемость)."],
        ["Backend", "Node.js, NestJS", "22.x, 10.x", "Серверная логика, GraphQL API, высокая производительность Node.js, модульность NestJS.", "P9 (Система - модульность), P8 (Долгосрочное - масштабируемость Node.js)."],
        ["ORM", "Prisma", "5.x", "Удобная и безопасная работа с базой данных (PostgreSQL).", "P3 (Качество - безопасность запросов), P9 (Система - абстракция БД)."],
        ["База данных", "PostgreSQL (Neon)", "15.x", "Основное хранилище структурированных данных. Надежная реляционная СУБД.", "P8 (Долгосрочное), P9 (Система), P12 (Прагматизм)."],
        ["Хранилище Файлов", "Cloudflare R2 (S3-совместимое)", "-", "Хранение медиафайлов и бинарных данных. Выгодно и масштабируемо.", "P10 (Активы), P12 (Прагматизм), P8 (Долгосрочное)."],
        ["Кэширование", "Redis", "7.x", "Кэширование данных, Rate Limiting, управление присутствием WebSocket.", "P9 (Система - эффективность), P3 (Качество - снижение нагрузки), P5 (Здоровье - отзывчивость)."],
        ["Асинхронность", "Kafka", "3.x", "Надежная асинхронная обработка фоновых задач (обработка изображений).", "P9 (Система - разделение ответственности), P3 (Качество - надежность)."],
        ["Оркестрация", "Kubernetes", "1.24+", "Управление контейнерами, автоматическое масштабирование, самовосстановление.", "P8 (Долгосрочное), P9 (Система - управление сложностью), P3 (Качество - отказоустойчивость)."],
        ["Инфраструктура", "Terraform", "1.5+", "Автоматизация создания и управления инфраструктурой (IaC).", "P9 (Система - автоматизация), P3 (Качество - предсказуемость инфраструктуры)."],
        ["Тестирование", "Jest, Cypress, Detox", "-", "Модульные, интеграционные, E2E-тесты для обеспечения <strong>качества</strong>.", "P3 (Качество), P9 (Система - автоматизация проверки)."],
        ["Профилирование", "V8 Profiler, Chrome DevTools", "-", "Инструменты для <strong>измерения и оптимизации производительности</strong>.", "P1 (Обучение), P9 (Система - Кайдзен), P13 (Настойчивость)."],
        ["Мониторинг Kafka", "Kafdrop", "-", "Визуальный мониторинг очередей Kafka.", "P9 (Система), P5 (Здоровье - системы, видимость проблем)."]
      ]
    },
    "codingStandards": {
      "title": "4. Стандарты Кодирования: Дисциплина как Основа Качества (Принцип 3, 9)",
      "intro": "Соблюдение стандартов кодирования — это проявление <strong>дисциплины</strong> и часть <strong>системы обеспечения качества</strong>. Это делает код предсказуемым, легко читаемым и поддерживаемым другими разработчиками (или вами самими в будущем).",
      "generalPrinciples": {
        "title": "4.1. Общие Принципы",
        "principles": [
          "<strong>DRY (Don’t Repeat Yourself):</strong> Избегайте дублирования кода. Используйте общие функции, компоненты, хуки в пакете <code>core</code>.",
          "<strong>KISS (Keep It Simple, Stupid):</strong> Стремитесь к простоте решений. Не усложняйте без необходимости. <strong>Упрощать сложное</strong> (Маргулан) применимо и к коду.",
          "<strong>Именование:</strong> Используйте английский язык для всех идентификаторов (переменные, функции, классы), комментариев. Будьте последовательны.",
          "<strong>Комментарии:</strong> Обязательны для:",
          "Сложной бизнес-логики (например, обработка платежей, управление WebSocket-соединениями).",
          "Интеграций с внешними сервисами (где могут быть неочевидные детали API).",
          "Критических участков кода (аутентификация, шифрование, работа с множествами).",
          "Неочевидных решений или обходных путей (с объяснением почему)."
        ]
      },
      "namingConventions": {
        "title": "4.2. Конвенции Именования",
        "conventions": [
          "<strong>Переменные и функции:</strong> <code>camelCase</code> (например, <code>getUserProfile</code>, <code>chatMessage</code>).",
          "<strong>Классы и модули:</strong> <code>PascalCase</code> (например, <code>UserService</code>, <code>ChatModule</code>).",
          "<strong>Константы:</strong> <code>UPPER_SNAKE_CASE</code> (например, <code>MAX_FILE_SIZE</code>, <code>DEFAULT_TIMEOUT</code>).",
          "<strong>Файлы и папки:</strong> <code>kebab-case</code> (например, <code>user-service.ts</code>, <code>chat-screen.tsx</code>, <code>image-processing</code>).",
          "<strong>API Endpoints (в контексте GraphQL):</strong> Резолверы и их поля именуются согласно доменной модели, часто следуя REST-подобной логике (например, query <code>getUser</code>, mutation <code>sendMessage</code>)."
        ]
      },
      "formattingLinting": {
        "title": "4.3. Форматирование и Линтинг: Автоматизация Поддержания Порядка",
        "intro": "Используйте автоматические инструменты для обеспечения единообразного форматирования и соблюдения базовых правил кодирования. Это часть <strong>системы автоматизации качества</strong> (Принцип 9).",
        "prettier_title": "<strong>Форматирование:</strong> <strong>Prettier</strong> — автоматический форматтер кода.",
        "prettier_content": "Настройте <code>.prettierrc</code> в корне проекта. Рекомендуемые настройки: 2 пробела для отступов, отсутствие точек с запятой в конце строк, одинарные кавычки для строк.",
        "prettier_code": "```json\\n{\\n  \\\"tabWidth\\\": 2,\\n  \\\"semi\\\": false,\\n  \\\"singleQuote\\\": true,\\n  \\\"trailingComma\\\": \\\"es5\\\"\\n}\\n```",
        "eslint_title": "<strong>Линтинг:</strong> <strong>ESLint</strong> — статический анализатор кода для выявления проблем.",
        "eslint_content": "Используйте конфигурацию вроде Airbnb или Standard, адаптированную для TypeScript, React/React Native, NestJS. Настройте правила в <code>.eslintrc.js</code>.\\nИнтегрируйте ESLint в ваш редактор кода для получения обратной связи в реальном времени."
      },
      "codeStructure": {
        "title": "4.4. Структура Кода: Модульность и Четкие Границы",
        "intro": "Код организован модульно внутри каждого пакета, следуя принципам <strong>системности</strong> (Принцип 9) и разделения ответственности.",
        "corePackage": {
          "title": "Core (<code>packages/core</code>):",
          "points": [
            "<code>api/</code>: Код для взаимодействия с GraphQL API BrainMessenger (Apollo Client).",
            "<code>hooks/</code>: Переиспользуемые хуки для React/React Native.",
            "<code>utils/</code>: Чистые функции-утилиты, не зависящие от конкретной платформы."
          ]
        },
        "mobileDesktopPackage": {
          "title": "Mobile-Desktop (<code>packages/mobile-desktop</code>):",
          "points": [
            "<code>components/</code>: Небольшие, переиспользуемые UI-компоненты (<code>Button</code>, <code>MessageBubble</code>).",
            "<code>screens/</code>: Компоненты, представляющие целые экраны (<code>ChatScreen</code>, <code>SettingsScreen</code>).",
            "<code>theme/</code>: Файлы с цветовыми схемами и типографикой, определенные в DocDesign.",
            "<code>platform/</code>: Код, специфичный для Android или Windows (например, работа с нативными модулями)."
          ]
        },
        "webPackage": {
          "title": "Web (<code>packages/web</code>):",
          "points": [
            "<code>pages/</code>: Компоненты страниц Next.js.",
            "<code>components/</code>: UI-компоненты для веба (могут переиспользовать логику из <code>core/hooks</code> или <code>core/utils</code>).",
            "<code>styles/</code>: Файлы стилей (Tailwind CSS)."
          ]
        },
        "backendPackage": {
          "title": "Backend (<code>backend</code>):",
          "points": [
            "Структура NestJS: Модули (<code>auth</code>, <code>user</code>, <code>chat</code>, <code>message</code>), сервисы (<code>AuthService</code>, <code>UserService</code>), контроллеры (для REST, если есть) или резолверы (для GraphQL), DTO (Data Transfer Objects), Entities (определенные Prisma).",
            "<code>src/</code>: Исходный код.",
            "<code>test/</code>: Тесты."
          ]
        }
      }
    },
    "libraries": {
      "title": "5. Используемые Библиотеки: Выбор Правильных Инструментов (Принцип 12)",
      "intro": "Мы выбираем библиотеки, которые решают задачи <strong>прагматично</strong> (Принцип 12), обеспечивают <strong>качество</strong> (Принцип 3) и хорошо интегрируются в нашу <strong>систему</strong> (Принцип 9).",
      "common": {
        "title": "5.1. Общие (Core)",
        "libs": [
          "<code>@apollo/client</code> (и связанные): Клиент GraphQL для выполнения запросов к Backend API. Используется в <code>core</code> и импортируется в <code>mobile-desktop</code> и <code>web</code>. Обеспечивает <strong>эффективность</strong> (Принцип 9) за счет управления кэшем."
        ]
      },
      "mobileDesktop": {
        "title": "5.2. Mobile-Desktop (React Native)",
        "libs": [
          "<code>react-native-reanimated</code>, <code>moti</code>, <code>lottie-react-native</code>: Библиотеки для создания <strong>плавных и производительных анимаций</strong> (см. DocDesign). Связано с Принципом 3 (Качество UI) и Принципом 5 (Здоровье - снижение нагрузки).",
          "<code>@react-navigation/native</code> (и связанные): Навигация между экранами приложения. <strong>Системное</strong> (Принцип 9) управление переходами.",
          "<code>react-native-sound</code>: Базовая библиотека для воспроизведения звуков (сообщения, звонки). См. Документацию звуков."
        ]
      },
      "web": {
        "title": "5.3. Web (Next.js)",
        "libs": [
          "<code>next</code>, <code>react</code>, <code>react-dom</code>: Основа веб-приложения. Next.js обеспечивает <strong>систему</strong> (Принцип 9) для SSR, SSG, маршрутизации и <strong>оптимизации</strong> (см. DocOptimizationIn).",
          "<code>tailwindcss</code>: Утилитарный CSS-фреймворк для быстрой и <strong>прагматичной</strong> (Принцип 12) стилизации.",
          "<code>framer-motion</code>: Библиотека для <strong>качественных</strong> (Принцип 3) анимаций в вебе."
        ]
      },
      "backend": {
        "title": "5.4. Backend (NestJS)",
        "libs": [
          "<code>@nestjs/*</code>: Основные пакеты NestJS (core, common, platform-express/fastify, graphql, typeorm/prisma, jwt, passport, websockets и т.д.). Обеспечивают <strong>модульную, масштабируемую систему</strong> (Принцип 9).",
          "<code>@nestjs/prisma</code>: Интеграция NestJS и Prisma.",
          "<code>graphql</code>, <code>@nestjs/graphql</code>, <code>apollo-server-express</code>: Реализация GraphQL API.",
          "<code>@prisma/client</code>: Клиент Prisma ORM для взаимодействия с Neon (PostgreSQL).",
          "<code>@aws-sdk/client-s3</code>, <code>@aws-sdk/s3-request-presigner</code>: Работа с Cloudflare R2 (S3-совместимый).",
          "<code>ioredis</code>: Клиент Redis для кэширования и других задач.",
          "<code>kafkajs</code>: Клиент Kafka для асинхронных задач.",
          "<code>firebase-admin</code>: SDK для Firebase (Push-уведомления).",
          "<code>stripe</code>: SDK для Stripe (Платежи).",
          "<code>googleapis</code>: SDK для Google APIs (Gmail API).",
          "<code>bcrypt</code> или <code>argon2</code>: Библиотека для <strong>безопасного</strong> (Принцип 3, 5) хэширования паролей."
        ]
      },
      "crossPackage": {
        "title": "5.5. Общие (Cross-Package)",
        "libs": [
          "<code>typescript</code>: Язык разработки.",
          "<code>winston</code> или <code>pino</code>: Библиотека для <strong>структурированного логирования</strong> (Принцип 9).",
          "<code>@sentry/node</code>, <code>@sentry/react</code>, <code>@sentry/react-native</code>: Клиенты Sentry для <strong>отслеживания ошибок</strong> в продакшене (часть системы <strong>качества</strong> и <strong>Кайдзен</strong>).",
          "<code>core-js</code>, <code>regenerator-runtime</code>: Полифиллы для поддержки современных возможностей JavaScript в старых средах (например, новые методы Set в ES2024).",
          "<code>zod</code> или <code>class-validator</code>/<code>class-transformer</code>: Библиотеки для <strong>валидации данных</strong>, обеспечения <strong>качества</strong> (Принцип 3) на входе в систему."
        ]
      },
      "setMethods": {
        "title": "5.6. Работа с Множествами (Set) в ES2024+: Пример Применения Новых Знаний (Принцип 1)",
        "intro": "<strong>Постоянное обучение</strong> (Принцип 1) и применение <strong>прагматичных</strong> (Принцип 12) инструментов языка — это часть нашей философии. Новые методы объекта <code>Set</code> в ECMAScript 2024 (поддержка в Node.js 22+, современных браузерах) предоставляют <strong>более чистый, читаемый и часто более эффективный</strong> (Принцип 9) способ работы с уникальными наборами данных по сравнению с ручными циклами или преобразованиями в массивы.",
        "areas": {
          "title": "Области применения в BrainMessenger:",
          "points": [
            "Управление списками пользователей в групповых чатах (добавление/удаление участников).",
            "Отслеживание уникальных активных сессий или соединений WebSocket.",
            "Управление правами доступа (проверка, входит ли набор разрешений в доступные).",
            "Синхронизация списков (например, контактов, чатов) между клиентом и сервером, определение добавленных/удаленных элементов."
          ]
        },
        "keys": {
          "title": "Ключевые Методы (из ES2024):",
          "points": [
            "<code>union(iterable)</code>: Возвращает новое <code>Set</code> со всеми уникальными элементами из текущего <code>Set</code> и переданного итерируемого объекта.",
            "<code>intersection(iterable)</code>: Возвращает новое <code>Set</code> с элементами, присутствующими в <strong>обоих</strong> множествах.",
            "<code>difference(iterable)</code>: Возвращает новое <code>Set</code> с элементами, присутствующими в текущем <code>Set</code>, но <strong>не</strong> в переданном итерируемом объекте.",
            "<code>symmetricDifference(iterable)</code>: Возвращает новое <code>Set</code> с элементами, которые есть в <strong>одном</strong>, но не в <strong>обоих</strong> множествах.",
            "<code>isSubsetOf(iterable)</code>: Проверяет, являются ли все элементы текущего <code>Set</code> подмножеством переданного итерируемого объекта (<code>true</code> или <code>false</code>).",
            "<code>isSupersetOf(iterable)</code>: Проверяет, содержит ли текущий <code>Set</code> все элементы переданного итерируемого объекта (<code>true</code> или <code>false</code>).",
            "<code>isDisjointFrom(iterable)</code>: Проверяет, не имеют ли текущий <code>Set</code> и переданный итерируемый объект общих элементов (<code>true</code> или <code>false</code>)."
          ]
        },
        "examples": {
          "title": "Примеры Использования в Коде (TypeScript):",
          "code": "```typescript\\n// backend/src/chat/chat.service.ts (пример управления участниками группы)\\nasync updateGroupMembers(groupId: string, currentMemberIds: Set<string>, newMemberIds: Set<string>) {\\n  // Принцип 9: Оптимизация и ясность\\n  const addedMembers = newMemberIds.difference(currentMemberIds);\\n  const removedMembers = currentMemberIds.difference(newMemberIds);\\n  const unchangedMembers = currentMemberIds.intersection(newMemberIds); // Для проверки\\n\\n  console.log('Added:', addedMembers);\\n  console.log('Removed:', removedMembers);\\n\\n  // Выполнить операции добавления/удаления в БД через Prisma\\n  if (addedMembers.size > 0) {\\n    await this.prisma.userChat.createMany({\\n      data: Array.from(addedMembers).map(userId => ({ groupId, userId })),\\n    });\\n  }\\n  if (removedMembers.size > 0) {\\n    await this.prisma.userChat.deleteMany({\\n      where: {\\n        groupId: groupId,\\n        userId: { in: Array.from(removedMembers) },\\n      },\\n    });\\n  }\\n\\n  // Проверка прав: Убедиться, что текущий пользователь имеет право изменять состав группы\\n  const requiredPermission = new Set(['manage_members']);\\n  const userPermissions = new Set(await this.getUserPermissions(userId, groupId)); // Получить права пользователя\\n  const hasPermission = requiredPermission.isSubsetOf(userPermissions); // Проверка через новый метод\\n  if (!hasPermission) {\\n      throw new ForbiddenException(\\\"Недостаточно прав для изменения состава группы.\\\");\\n  }\\n}\\n\\n// frontend/src/hooks/useChats.ts (пример синхронизации списка чатов)\\nfunction useSyncChats(localChats: Set<string>, serverChats: string[]) {\\n    // Принцип 9: Эффективность синхронизации\\n    const serverChatsSet = new Set(serverChats);\\n    const newChats = serverChatsSet.difference(localChats);\\n    const removedChats = localChats.difference(serverChatsSet);\\n\\n    console.log('Новые чаты:', newChats);\\n    console.log('Удаленные чаты:', removedChats);\\n\\n    // Обновить локальное состояние/UI на основе newChats и removedChats\\n    // ...\\n}\\n",
          "recommendations": [
            "Применяйте их для операций с уникальными наборами данных. Они разработаны специально для этого и часто более производительны, чем аналогичные операции с массивами, особенно для больших объемов данных.",
            "Учитывайте совместимость: Новые методы доступны в Node.js 22+ и современных браузерах. Если вам нужно поддерживать старые среды, используйте полифиллы (core-js/proposals/set-methods-v2).",
            "Типизация в TypeScript: Всегда указывайте тип элементов в Set (например, Set<string>, Set<number>) для лучшей проверки типов и автодополнения."
          ]
        }
      }
    },
    "devProcess": {
      "title": "6. Процесс Разработки: Наша Система Рабочего Потока (Принцип 9)",
      "intro": "Четкий процесс разработки обеспечивает системность, качество и предсказуемость (Принцип 9).",
      "envSetup": {
        "title": "6.1. Установка Окружения: Подготовка к Работе",
        "intro": "Клонируйте репозиторий:",
        "cloneRepo": {
          "title": "Клонируйте репозиторий:",
          "code": "```bash\\ngit clone <https://github.com/xAI/BrainMessenger.git> # Приклад\\ncd BrainMessenger\\n```"
        },
        "installDeps": {
          "title": "Установите зависимости:",
          "code": "```bash\\nnpm install\\n```"
        },
        "envVars": {
          "title": "Настройте переменные окружения:",
          "code": "```bash\\ncp .env.example .env\\n# Заполните .env данными для Neon, R2, Redis, Kafka, API Gateways, Stripe, Firebase, Gmail API\\n```",
          "note": "Важно иметь рабочие локальные или тестовые инстансы БД, Redis, Kafka или использовать их облачные версии для разработки."
        },
        "prismaClient": {
          "title": "Сгенерируйте Prisma Client:",
          "code": "```bash\\ncd backend\\nnpx prisma generate\\ncd ..\\n```"
        },
        "localDb": {
          "title": "Настройте локальную БД (если не используете облачную):",
          "code": "```bash\\ncd backend\\nnpx prisma migrate dev --name initial_setup\\ncd ..\\n```"
        }
      },
      "localRun": {
        "title": "6.2. Локальный Запуск: Активация Системы для Разработки",
        "intro": "Используйте команды turbo run или специфические команды пакетов.",
        "runAll": {
          "title": "Запуск всех сервисов (Backend, Web) для разработки:",
          "code": "```bash\\nturbo run dev # Запустит dev-серверы для всех пакетов с задачей 'dev' в turbo.json\\n```"
        },
        "runBackend": {
          "title": "Отдельный запуск Backend:",
          "code": "```bash\\ncd backend\\nnpm run start:dev # или npm run start:debug для отладки\\n```"
        },
        "runMobileDesktop": {
          "title": "Отдельный запуск Mobile-Desktop (React Native):",
          "code": "```bash\\ncd packages/mobile-desktop\\nnpm run android # для запуска на Android эмуляторе/устройстве\\nnpm run windows # для запуска на Windows\\n```"
        },
        "runWeb": {
          "title": "Отдельный запуск Web (Next.js):",
          "code": "```bash\\ncd packages/web\\nnpm run dev\\n```"
        }
      }
    },
    "commitsBranches": {
      "title": "6.3. Коммиты и Ветки: Структура Развития Кода (Принцип 9)",
      "intro": "Мы используем четкую стратегию веток и стандарты для коммитов для поддержания порядка (Принцип 9) и ясной истории изменений (Принцип 7).",
      "mainBranches": {
        "title": "Основная ветка разработки:",
        "points": [
          "<code>develop</code>. Все новые функции и исправления интегрируются сюда.",
          "Стабильная ветка: <code>main</code>. Только проверенный код из <code>develop</code> (через релизные PR)."
        ]
      },
      "workBranches": {
        "title": "Ветки для работы:",
        "points": [
          "<code>feature/<название_фичи></code>: Для разработки новой функциональности (например, <code>feature/graphql-auth</code>).",
          "<code>fix/<название_исправления></code>: Для исправления ошибок (например, <code>fix/chat-message-scroll</code>).",
          "<code>refactor/<название></code>: Для рефакторинга кода."
        ]
      },
      "commitFormat": {
        "title": "Формат коммитов:",
        "example": "Используйте Conventional Commits. Это упрощает генерацию changelog и понимание цели каждого коммита.\\n\\nПример:\\n\\n<code>feat(backend/auth): add JWT authentication</code> (новая функция в модуле аутентификации backend)\\n\\n<code>fix(mobile/chat): resolve message display bug on scroll</code> (исправление бага отображения сообщений в мобильном чате)\\n\\n<code>docs(roadmap): update Q3 2025 plan</code> (обновление документации)\\n\\n<code>chore(deps): update prisma to 5.x</code> (рутинная задача, обновление зависимости)",
        "structure": "Структура: <code>тип(scope): описание</code>\\n\\n<code>тип</code>: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>chore</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>ci</code>, <code>perf</code>, <code>build</code>\\n\\n<code>scope</code>: Необязательно, указывает пакет или область (<code>backend</code>, <code>web</code>, <code>mobile-desktop</code>, <code>core</code>, <code>auth</code>, <code>chat</code>, <code>ui</code>, <code>infra</code> и т.п.)."
      }
    },
    "prCodeReview": {
      "title": "6.4. Pull Request (PR) и Код-Ревью: Коллективное Обеспечение Качества (Принцип 3, 14)",
      "intro": "Каждый Pull Request — это возможность получить обратную связь (Принцип 14), улучшить код и обеспечить качество (Принцип 3) перед интеграцией в основную ветку.",
      "prDescription": {
        "title": "Описание PR:",
        "points": [
          "Четко опишите, какую проблему решает PR или какую функцию добавляет.",
          "Ссылайтесь на соответствующую задачу в Jira (например, [BM-123]) или другое место отслеживания задач.",
          "Опишите основные изменения и любые потенциальные риски или вопросы."
        ]
      },
      "prRequirements": {
        "title": "Требования к PR:",
        "points": [
          "Код должен соответствовать стандартам кодирования (линтер, форматтер).",
          "Все тесты должны проходить (<code>npm test</code>). Настройте проверку в GitHub Actions.",
          "Должно быть минимум 1 одобрение (аппрув) от другого разработчика (или от вас самого, если работаете в одиночку, но стремитесь к идеалу код-ревью).",
          "Для нетривиальных изменений может потребоваться ревью от более опытного разработчика или архитектора."
        ]
      }
    },
    "testing": {
      "title": "6.5. Тестирование: Проверка Надежности Системы (Принцип 3)",
      "intro": "Тестирование — неотъемлемая часть процесса обеспечения качества (Принцип 3). Мы используем многоуровневый подход.",
      "runAllTests": {
        "title": "Запуск всех тестов:",
        "code": "```bash\\nnpm run test # Запустит тесты для всех пакетов (unit, integration)\\n```"
      },
      "testTypes": {
        "title": "Виды тестов:",
        "points": [
          "Модульные тесты (Unit Tests): Тестирование отдельных функций или классов изолированно (Jest). Фокус: Корректность мелких частей кода.",
          "Интеграционные тесты (Integration Tests): Тестирование взаимодействия между несколькими компонентами (например, сервис -> БД, API -> сервис) (Jest). Фокус: Правильность связей между частями системы.",
          "E2E-тесты (End-to-End Tests): Тестирование пользовательских сценариев в приложении (Cypress для Web, Detox для React Native). Фокус: Работа системы в целом с точки зрения пользователя."
        ]
      },
      "ciCdTests": {
        "title": "Настройте автоматический запуск тестов в CI/CD (GitHub Actions) на каждый PR и пуш в develop.",
        "content": "Настройте автоматический запуск тестов в CI/CD (GitHub Actions) на каждый PR и пуш в develop."
      }
    }
  },
  "devRecommendations": {
    "title": "7. Рекомендации по Разработке: Лучшие Практики Построения Актива",
    "intro": "Применяйте эти рекомендации для создания качественного, поддерживаемого кода, который станет основой вашего цифрового Актива (Принцип 3, 10).",
    "corePackage": {
      "title": "7.1. Core Пакет: Переиспользование для Эффективности",
      "points": [
        "API-клиент (<code>@apollo/client</code>): Используйте его для всех запросов GraphQL из Frontend. Настройте кэширование (InMemoryCache) и обработку ошибок. Это снижает дублирование кода и обеспечивает единый способ взаимодействия с API.",
        "Общие Хуки/Утилиты: Выносите сюда логику, которая повторяется на разных платформах (форматирование данных, валидация, работа с токенами)."
      ]
    },
    "mobileDesktop": {
      "title": "7.2. Mobile-Desktop (React Native)",
      "points": [
        "Функциональные Компоненты: Используйте React Hooks и функциональные компоненты. Разделяйте компоненты на \"умные\" (с логикой) и \"глупые\" (только UI).",
        "Стилизация: Используйте StyleSheet.create для производительности или библиотеки вроде styled-components / NativeBase для системности.",
        "Нативная Оптимизация: Изучите специфику RNW и RN (например, работа с нативными модулями для повышения производительности критических участков, анимации на нативном потоке с Reanimated)."
      ]
    },
    "web": {
      "title": "7.3. Web (Next.js)",
      "points": [
        "Маршрутизация и Fetching: Используйте возможности Next.js (File-system routing, getStaticProps, getServerSideProps, getStaticPaths) для оптимизации загрузки страниц (SSR/SSG) и SEO (Принцип 2).",
        "Стилизация: Tailwind CSS ускоряет разработку UI. Следуйте принципам из DocDesign.",
        "Оптимизация Изображений: Используйте next/image для автоматической оптимизации изображений."
      ]
    },
    "backend": {
      "title": "7.4. Backend (NestJS)",
      "points": [
        "GraphQL API: Следуйте принципам GraphQL (запрашивать только нужное). Используйте DataLoader для решения проблемы N+1 (см. DocOptimizationIn).",
        "Prisma: Используйте ORM для всех взаимодействий с БД. Это обеспечивает безопасность (защита от SQL-инъекций - Принцип 3, 5) и типизацию.",
        "Сервисы: Выносите основную бизнес-логику в сервисы. Контроллеры/Резолверы должны быть тонкими (только обработка запроса и вызов сервиса).",
        "Интеграции: Взаимодействие с внешними сервисами (R2, Firebase, Stripe, Gmail API) должно быть инкапсулировано в отдельных сервисах (например, StorageService, NotificationService). Это делает код более модульным и тестируемым (Принцип 9).",
        "Обработка Ошибок: Используйте фильтры исключений NestJS для централизованной обработки ошибок и возврата стандартизированных ответов API (см. DocSpec). Логируйте ошибки подробно (Winston, Sentry)."
      ]
    },
    "security": {
      "title": "7.5. Безопасность: Защита Вашего Актива (Принцип 3, 5, 10)",
      "intro": "Безопасность — это не фича, а фундаментальный аспект качества (Принцип 3), напрямую связанный со здоровьем системы (Принцип 5) и защитой цифрового актива (Принцип 10: ваш продукт и данные пользователей).",
      "points": [
        "Аутентификация: Используйте JWT для stateless аутентификации с короткоживущими access-токенами и refresh-токенами. Надежно храните секрет JWT.",
        "Хэширование Паролей: Никогда не храните пароли в открытом виде. Используйте надежные алгоритмы хэширования (bcrypt, argon2).",
        "Валидация Ввода: Строго валидируйте все входящие данные на Backend (например, с помощью class-validator и DTO).",
        "Защита от Атак: Внедрите Rate Limiting (<code>@nestjs/throttler</code>) для защиты от перебора паролей или DDoS на уровне API. Используйте helmet для установки безопасных HTTP-заголовков.",
        "Шифрование Чувствительных Данных: Шифруйте данные перед сохранением в R2 (см. DocInt). Надежно храните ключ шифрования отдельно от данных.",
        "2FA: Реализуйте двухфакторную аутентификацию как опцию для пользователей."
      ]
    }
    },
    "optimization": {
      "title": "8. Оптимизация Проекта: Постоянное Улучшение (Принцип 9, 1)",
      "content": "Оптимизация — это итеративный процесс (Принцип 9: Кайдзен), основанный на измерении и обучении (Принцип 1). См. подробное Руководство по оптимизации BrainMessenger."
    },
    "deployProcess": {
      "title": "9. Процесс Деплоя: Доставка Системы Пользователям (Принцип 9)",
      "intro": "Процесс деплоя должен быть автоматизированным, надежным и предсказуемым (Принцип 9, 3).",
      "points": [
        "Контейнеризация (Docker): Создайте Docker-образы для Backend и других сервисов. Используйте многоступенчатую сборку для оптимизации размера образов (см. Руководство по оптимизации CI/CD).",
        "Оркестрация (Kubernetes): Развертывайте контейнеры в Kubernetes. Используйте манифесты в папке <code>infrastructure/k8s</code>. K8s обеспечивает автоматическое масштабирование, самовосстановление и управление нагрузкой.",
        "Инфраструктура как Код (Terraform): Управляйте облачными ресурсами (кластер K8s, сети) с помощью Terraform (<code>infrastructure/main.tf</code>). Это делает инфраструктуру версионируемой и воспроизводимой.",
        "CI/CD (GitHub Actions): Настройте автоматические пайплайны для сборки, тестирования и деплоя (см. Руководство по оптимизации CI/CD)."
      ],
      "process": "Процесс: Код пушится в <code>develop</code> → CI/CD запускает тесты и сборку → После успешного прохождения тестов и ревью, PR мержится в <code>develop</code> → (опционально) автоматический деплой dev/staging окружения → Релизный PR из <code>develop</code> в <code>main</code> → Деплой продакшена."
    },
    "devCommands": {
      "title": "10. Полезные Команды Разработчика: Инструментарий Системы",
      "table": [
        ["Команда", "Описание", "Расположение"],
        ["<code>npm install</code>", "Устанавливает зависимости для всех пакетов (Turborepo).", "Корень"],
        ["<code>turbo run <task></code>", "Запускает задачу (build, test, lint, dev) для всех пакетов или по фильтру.", "Корень"],
        ["<code>npm run lint</code>", "Запускает линтеры для всех пакетов.", "Корень"],
        ["<code>npm run format</code>", "Форматирует код всех пакетов (Prettier).", "Корень"],
        ["<code>npm run build</code>", "Собирает продакшен-версии всех пакетов.", "Корень"],
        ["<code>npm run test</code>", "Запускает тесты для всех пакетов.", "Корень"],
        ["<code>cd backend && npx prisma migrate dev --name <name></code>", "Создает и применяет новую миграцию БД.", "Корень/backend"],
        ["<code>cd backend && npx prisma studio</code>", "Запускает графический интерфейс для просмотра БД.", "Корень/backend"],
        ["<code>cd backend && npm run start:dev</code>", "Запускает backend в режиме разработки.", "Корень/backend"],
        ["<code>cd packages/web && npm run dev</code>", "Запускает веб-приложение в режиме разработки.", "Корень/packages/web"],
        ["<code>cd packages/mobile-desktop && npm run android</code>", "Запускает мобильное приложение на Android.", "Корень/packages/mobile-desktop"],
        ["<code>cd packages/mobile-desktop && npm run windows</code>", "Запускает десктоп на Windows.", "Корень/packages/mobile-desktop"],
        ["<code>cd infrastructure && terraform plan</code>", "Показывает план изменений инфраструктуры.", "Корень/infrastructure"],
        ["<code>cd infrastructure && terraform apply</code>", "Применяет изменения инфраструктуры.", "Корень/infrastructure"]
      ]
    },
    "notes": {
      "title": "11. Примечания: Постоянное Обучение и Кайдзен",
      "points": [
        "Онбординг: Новые разработчики должны начать с изучения этой документации, а также Технической документации (общий обзор), Документации дизайна (визуальные стандарты) и Руководства по оптимизации (как писать производительный код).",
        "Живой Документ: Эта документация является живым документом. Она будет обновляться по мере развития проекта, изучения новых технологий и улучшения процессов. Ваши предложения по улучшению приветствуются! (Принцип 1, 14).",
        "Совместимость ECMAScript 2024: Убедитесь, что используете Node.js 22+ (для backend) и актуальные версии браузеров/React Native (для frontend) для полной поддержки новых методов Set. При необходимости используйте полифиллы.",
        "Вопросы и Обратная Связь: Если что-то непонятно, или вы видите возможность улучшить процесс — задавайте вопросы в командном чате (#dev-team в Slack или другом инструменте) и предлагайте изменения. Это часть Силы Взаимодействия и Содействия (Маргулан), которая делает систему сильнее."
      ]
    },
  "integrationsGuide": {
    "title": "Документация Интеграций BrainMessenger",
    "subtitle": "Построение Надежной Системы с Внешними Рычагами",
    "introduction": {
      "title": "1. Введение: Интеграции как Часть Фундамента Системы",
      "description": "Этот документ описывает, как BrainMessenger интегрируется с ключевыми внешними сервисами. Мы выбираем эти интеграции <strong>прагматично</strong> (Принцип 12), рассматривая их как <strong>рычаги</strong> (принцип Маргулана), которые позволяют нам не изобретать колесо, а использовать <strong>надежные и масштабируемые</strong> (Принцип 8, 9) сторонние решения для ускорения разработки и обеспечения <strong>качества</strong> (Принцип 3) нашего продукта. Эти интеграции являются неотъемлемой частью нашего <strong>технологического фундамента</strong> (Принцип 8).",
      "principlesTitle": "Принципы, которыми руководствуется выбор и настройка интеграций:",
      "principles": [
        "<strong>Система и Оптимизация (Принцип 9):</strong> Интеграции должны быть частью единой, хорошо продуманной системы, где каждый компонент выполняет свою роль эффективно.",
        "<strong>Прагматизм и Реализм (Принцип 12):</strong> Выбор сервисов с учетом текущих потребностей, бюджета (бесплатные/доступные тарифы на старте) и простоты интеграции.",
        "<strong>Долгосрочное Мышление (Принцип 8):</strong> Выбор сервисов, способных масштабироваться вместе с ростом проекта.",
        "<strong>Качество > Количество (Принцип 3):</strong> Фокус на надежности и производительности интеграций, даже если их список на старте небольшой.",
        "<strong>Создание Ценности (Принцип 2):</strong> Каждая интеграция должна добавлять реальную ценность для конечного пользователя (например, надежное хранение файлов, мгновенные уведомления)."
      ]
    },
    "overview": {
      "title": "2. Обзор Ключевых Интеграций: Наши Внешние Компоненты Системы",
      "table": [
        ["Сервис", "Назначение", "Роль в BrainMessenger", "Основные функции", "Связь с Принципами"],
        ["<strong>Neon</strong>", "Управляемый PostgreSQL БД", "Хранение всех <strong>структурированных данных</strong> (пользователи, чаты, сообщения, метаданные файлов). Фундамент данных.", "Хостинг PostgreSQL, масштабирование, доступ через строку подключения.", "P8 (Долгосрочное), P9 (Система), P12 (Прагматизм - бесплатный тариф)."],
        ["<strong>Cloudflare R2</strong>", "Облачное Хранилище (S3-совместимое)", "Хранение всех <strong>неструктурированных данных</strong> (файлы пользователей, аватарки, записи звонков, зашифрованные метаданные). Хранилище Активов.", "Надежное хранение объектов, CDN-доставка, отсутствие платы за исходящий трафик.", "P8 (Долгосрочное), P10 (Активы), P12 (Прагматизм - бесплатный тариф, нет платы за трафик), P3 (Качество - CDN)."],
        ["<strong>Firebase</strong>", "Push-уведомления", "Мгновенная доставка уведомлений пользователям на мобильные устройства.", "Отправка push-уведомлений (FCM).", "P2 (Ценность - информирование), P9 (Система - надежная доставка), P12 (Прагматизм - готовое решение)."],
        ["<strong>Stripe</strong>", "Платежная Система", "Обработка платежей за Premium-подписку. Доступ к платежам как к рычагу создания Ценности/Богатства.", "Прием платежей, управление подписками.", "P2 (Ценность - премиум), P10 (Богатство/Активы), P9 (Система - автоматизация платежей)."],
        ["<strong>Gmail API</strong>", "Сервис отправки email", "Отправка критически важных email (коды подтверждения для регистрации и 2FA).", "Отправка транзакционных email.", "P3 (Качество - надежная доставка email), P9 (Система - часть аутентификации), P5 (Здоровье - безопасность пользователя)."]
      ]
    },
    "neonIntegration": {
      "title": "3. Интеграция с Neon: Фундамент Структурированных Данных",
      "generalInfo": {
        "title": "3.1. Общая Информация",
        "description": "Neon предоставляет управляемый сервис PostgreSQL. Мы используем его как <strong>основное хранилище структурированных данных</strong>, таких как информация о пользователях, чатах, сообщениях и метаданных файлов.",
        "advantages": [
          "<strong>Прагматизм (P12):</strong> Бесплатный тариф на старте (30 ГБ) полностью покрывает начальные потребности.",
          "<strong>Система и Долгосрочное Мышление (P9, P8):</strong> Управляемый сервис снижает операционную нагрузку, автоматическое масштабирование и репликация доступны на платных планах, обеспечивая готовность к росту.",
          "<strong>Качество (P3):</strong> Надежность и производительность PostgreSQL как проверенной СУБД."
        ],
        "role": "Роль: Ядро, к которому обращается Backend для всех CRUD-операций над метаданными."
      },
      "configuration": {
        "title": "3.2. Конфигурация: Подключение к Системе Данных",
        "steps": [
          "1. <strong>Регистрация и Создание Проекта:</strong>",
          "Создайте аккаунт на `https://neon.tech`.",
          "Создайте новый проект (например, `brainmessenger-prod`) в консоли Neon.",
          "2. <strong>Настройка Базы Данных:</strong>",
          "Neon автоматически предоставляет инстанс PostgreSQL.",
          "<strong>Примените схему базы данных:</strong> Используйте Prisma Migrate для инициализации структуры таблиц (см. `database/schema.prisma` и Руководство по разработке).",
          "3. <strong>Переменные Окружения:</strong>",
          "Получите <strong>строку подключения</strong> (Connection Details) из консоли Neon (Settings → Connection Details).",
          "Добавьте в ваш `.env` файл:"
        ],
        "envExample": "```env\\n# Строка подключения к базе данных Neon\\nDATABASE_URL=postgresql://<user>:<password>@<neon-host>/<dbname>?sslmode=require\\n```",
        "note1": "*Примечание:* Используйте `sslmode=require` для безопасного соединения.",
        "backendCode": "4. <strong>Подключение Backend (NestJS + Prisma):</strong>\\nPrisma использует `DATABASE_URL` для подключения. Убедитесь, что Prisma Client сгенерирован (`npx prisma generate`).\\nИспользуйте `PrismaService` (из `nestjs-prisma`) для всех операций с БД.\\n```typescript\\n// backend/src/app.module.ts (или db.module.ts)\\nimport { Module } from '@nestjs/common';\\nimport { PrismaService } from 'nestjs-prisma'; // Убедитесь, что PrismaModule импортирован в app.module\\n\\n@Module({\\n  providers: [PrismaService], // PrismaService доступен для инъекции\\n  exports: [PrismaService],\\n})\\nexport class DbModule {}\\n```"
      },
      "interactionScenarios": {
        "title": "3.3. Методы и Сценарии Взаимодействия: API Данных",
        "description": "Все взаимодействия с Neon происходят через Prisma ORM в Backend, что обеспечивает <strong>типизацию, безопасность и системность</strong> (Принцип 3, 9).",
        "signup": {
          "title": "Сценарий: Регистрация пользователя:",
          "interaction": "<strong>Взаимодействие:</strong> Backend получает данные пользователя → Использует `PrismaService` для создания новой записи в таблице `users`.",
          "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/auth/auth.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { Prisma } from '@prisma/client'; // Импорт типов Prisma\\n\\n@Injectable()\\nexport class AuthService {\\n  constructor(private prisma: PrismaService) {}\\n\\n  async signUp(data: Prisma.UserCreateInput) {\\n    // Пример: пароль должен быть захэширован ДО сохранения\\n    const hashedPassword = await hashPassword(data.password); // Использование утилиты для хэширования\\n    return this.prisma.user.create({\\n      data: {\\n        email: data.email,\\n        name: data.name,\\n        password: hashedPassword, // Сохраняем захэшированный пароль\\n        // ... другие поля по схеме\\n      },\\n    });\\n  }\\n}\\n```",
          "result": "<strong>Результат:</strong> Данные пользователя надежно сохранены в Neon."
        },
        "getChats": {
          "title": "Сценарий: Получение списка чатов пользователя:",
          "interaction": "<strong>Взаимодействие:</strong> Frontend запрашивает чаты через GraphQL API → Backend использует `PrismaService` для выполнения запроса к таблице `chats` (возможно, с фильтрацией по `userId` и `include` для метаданных).",
          "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/chat/chat.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport { PrismaService } from 'nestjs-prisma';\\n\\n@Injectable()\\nexport class ChatService {\\n  constructor(private prisma: PrismaService) {}\\n\\n  async getUserChats(userId: string) {\\n    // Используем индексы @@index([userId]) для оптимизации (Принцип 9, Оптимизация)\\n    return this.prisma.chat.findMany({\\n      where: {\\n        users: { // Предполагается связь Many-to-Many с таблицей UserChat\\n          some: {\\n            userId: userId,\\n          },\\n        },\\n      },\\n      select: { // Выбираем только необходимые поля (Принцип 9, Оптимизация)\\n        id: true,\\n        name: true,\\n        type: true,\\n        // ... другие нужные поля\\n      },\\n      orderBy: { // Сортировка по дате последнего сообщения для актуальности (Принцип 2, Ценность)\\n        lastMessageAt: 'desc',\\n      },\\n    });\\n  }\\n}\\n```"
        },
        "saveMessage": {
          "title": "Сценарий: Сохранение сообщения:",
          "interaction": "<strong>Взаимодействие:</strong> Пользователь отправляет сообщение → Frontend отправляет его через GraphQL API → Backend использует `PrismaService` для создания новой записи в таблице `messages`, связывая ее с `chatId` и `userId`.",
          "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/message/message.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { Prisma } from '@prisma/client';\\n\\n@Injectable()\\nexport class MessageService {\\n  constructor(private prisma: PrismaService) {}\\n\\n  async createMessage(data: Prisma.MessageCreateInput) {\\n    // Используем транзакцию, если нужно обновить дату последнего сообщения в чате\\n    return this.prisma.$transaction(async (tx) => {\\n      const message = await tx.message.create({ data });\\n      await tx.chat.update({\\n        where: { id: data.chatId },\\n        data: { lastMessageAt: message.createdAt }, // Обновляем время последнего сообщения\\n      });\\n      return message;\\n    });\\n  }\\n}\\n```"
        }
      },
      "errorHandling": {
        "title": "3.4. Обработка Ошибок Интеграции: Поддержание Качества Системы",
        "description": "Надежная система должна уметь обрабатывать ошибки внешних зависимостей (Принцип 3: Качество).",
        "connectionError": {
          "title": "Connection Error:",
          "cause": "Причина: Невозможно установить соединение с Neon. Неверная строка подключения (`DATABASE_URL`), проблемы с сетью, недоступность сервиса Neon.",
          "solution": "Решение: Проверить переменную окружения `DATABASE_URL`, статус сервиса Neon. Логировать ошибку на Backend (Sentry/Winston)."
        },
        "queryError": {
          "title": "Database Query Error:",
          "cause": "Причина: Ошибка выполнения запроса к БД (например, нарушение уникальности, неверный тип данных). Ошибка в логике Backend, несоответствие схемы БД.",
          "solution": "Решение: Отладить запрос в Backend, проверить логи Prisma. Логировать ошибку."
        },
        "rateLimitError": {
          "title": "Rate Limit Exceeded (на платных тарифах):",
          "cause": "Причина: Превышены лимиты на количество запросов или вычислительные ресурсы в Neon. Высокая нагрузка, неоптимизированные запросы, недостаточный тарифный план.",
          "solution": "Решение: Оптимизировать запросы (см. Руководство по оптимизации), рассмотреть переход на более высокий тарифный план Neon."
        }
      }
    },
    "r2Integration": {
      "title": "4. Интеграция с Cloudflare R2: Хранилище Цифровых Активов",
      "generalInfo": {
        "title": "4.1. Общая Информация",
        "description": "Cloudflare R2 — это сервис объектного хранилища, совместимый с S3 API. Мы используем его для хранения <strong>всех файлов пользователей</strong>, таких как изображения, видео, документы, а также зашифрованные данные.",
        "advantages": [
          "<strong>Прагматизм (P12), Создание Богатства/Активов (P10):</strong> <strong>Отсутствие платы за исходящий трафик</strong> — критически важное преимущество для мессенджера, где пользователи активно обмениваются файлами. Бесплатный тариф 10 ГБ на старте.",
          "<strong>Качество (P3):</strong> Высокая производительность и надежность благодаря глобальной сети Cloudflare.",
          "<strong>Долгосрочное Мышление (P8), Система (P9):</strong> S3-совместимый API позволяет легко использовать стандартные библиотеки и инструменты, обеспечивая гибкость в будущем."
        ],
        "role": "Роль: Децентрализованное хранилище для крупных бинарных объектов, снижающее нагрузку на основную базу данных."
      },
      "configuration": {
        "title": "4.2. Конфигурация: Подключение к Хранилищу Активов",
        "steps": [
          "1. <strong>Создание Бакета:</strong>",
          "Войдите в Cloudflare Dashboard → R2.",
          "Нажмите <strong>\"Create Bucket\"</strong>.",
          "Назовите бакет (например, `brainmessenger-files`). Название должно быть уникальным в рамках всех аккаунтов Cloudflare.",
          "<strong>Настройки:</strong> Включите шифрование в покое (Encryption at rest) — это часть нашей <strong>системы безопасности</strong> (Принцип 3, 5). Ограничьте публичный доступ к бакету, доступ будет осуществляться через подписанные URL (если требуется) или через Backend.",
          "2. <strong>Ключи Доступа:</strong>",
          "В Cloudflare Dashboard перейдите в R2 → Manage R2 API Tokens.",
          "Создайте новый API-токен. Предоставьте ему минимально необходимые разрешения (например, Read and Write to specific buckets).",
          "Скопируйте `Access Key ID` и `Secret Access Key`.",
          "3. <strong>Переменные Окружения:</strong>",
          "Добавьте в ваш `.env` файл:"
        ],
        "envExample": "```env\\n# Cloudflare R2 Credentials\\nR2_ENDPOINT=<Your R2 Endpoint> # Формат: https://<account-id>.r2.cloudflarestorage.com\\nR2_ACCESS_KEY=<Your Access Key ID>\\nR2_SECRET_KEY=<Your Secret Access Key>\\nR2_BUCKET=brainmessenger-files # Название вашего бакета\\n\\n# Ключ шифрования для конфиденциальных данных (важно для P3, P5, P10)\\nENCRYPTION_KEY=<Your 32-byte (256-bit) hex or base64 encryption key> # Сгенерируйте надежный ключ!\\n```",
        "note": "*Примечание:* <strong>Не коммитьте эти ключи в Git!</strong> (Принцип 3, 5, 6). Используйте `.env.example` без чувствительных данных. <strong>ENCRYPTION_KEY</strong> должен быть сгенерирован надежно и храниться в безопасности.",
        "backendCode": "4. <strong>Подключение Backend (`@aws-sdk/client-s3`):</strong>\\nR2 совместим с S3 API, поэтому можно использовать стандартный AWS SDK для S3.\\nУстановите SDK: `npm install @aws-sdk/client-s3`.\\nИнициализируйте S3 Client в вашем Backend-сервисе (например, `StorageService`).\\n```typescript\\n// backend/src/storage/storage.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';\\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'; // Для подписанных URL\\nimport { createCipheriv, randomBytes, createDecipheriv } from 'crypto'; // Для шифрования\\n\\n@Injectable()\\nexport class StorageService {\\n  private r2: S3Client;\\n  private encryptionKey: Buffer; // Ключ для шифрования\\n\\n  constructor() {\\n    this.r2 = new S3Client({\\n      region: 'auto', // R2 не использует регионы в классическом понимании\\n      endpoint: process.env.R2_ENDPOINT,\\n      credentials: {\\n        accessKeyId: process.env.R2_ACCESS_KEY,\\n        secretAccessKey: process.env.R2_SECRET_KEY,\\n      },\\n    });\\n    // Важно: ENCRYPTION_KEY должен быть Buffer 32 байт для aes-256-cbc\\n    this.encryptionKey = Buffer.from(process.env.ENCRYPTION_KEY, 'hex'); // Или 'base64'\\n    if (this.encryptionKey.length !== 32) {\\n         // Логировать ошибку или выбросить исключение - ключ неверной длины\\n         console.error(\\\"Invalid ENCRYPTION_KEY length. Must be 32 bytes for aes-256-cbc.\\\");\\n         // process.exit(1); // Возможно, стоит остановить приложение\\n    }\\n  }\\n\\n  // Утилита для шифрования (часть системы безопасности - P3, P5)\\n  private encrypt(data: string): { encrypted: string, iv: string } {\\n    const iv = randomBytes(16); // Initialization Vector, 16 байт для aes-256-cbc\\n    const cipher = createCipheriv('aes-256-cbc', this.encryptionKey, iv);\\n    let encrypted = cipher.update(data, 'utf8', 'hex');\\n    encrypted += cipher.final('hex');\\n    return { encrypted, iv: iv.toString('hex') };\\n  }\\n\\n  // Утилита для дешифрования\\n  private decrypt(encrypted: string, iv: string): string {\\n      const decipher = createDecipheriv('aes-256-cbc', this.encryptionKey, Buffer.from(iv, 'hex'));\\n      let decrypted = decipher.update(encrypted, 'hex', 'utf8');\\n      decrypted += decipher.final('utf8');\\n      return decrypted;\\n  }\\n\\n  // ... методы для работы с R2 (загрузка, скачивание, удаление)\\n}\\n```"
      },
      "interactionScenarios": {
        "title": "4.3. Методы и Сценарии Взаимодействия: API Хранилища",
        "description": "Взаимодействие с R2 осуществляется через Backend, что позволяет контролировать доступ, обрабатывать файлы (например, оптимизация изображений перед загрузкой) и управлять метаданными в БД (Принцип 9: Система).",
        "uploadFile": {
          "title": "Сценарий: Загрузка файла пользователем:",
          "interaction": "<strong>Взаимодействие:</strong> Пользователь прикрепляет файл в чате → Frontend отправляет файл на Backend → Backend (`StorageService`) загружает файл в R2 → Backend сохраняет метаданные файла (URL, тип, размер) в Neon → Backend отправляет сообщение в чат с ссылкой на файл.",
          "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/storage/storage.service.ts (продолжение)\\n// ... S3Client и encryptionKey инициализация ...\\n\\nasync uploadFile(fileBuffer: Buffer, fileName: string, mimeType: string): Promise<string> {\\n  const key = `uploads/${Date.now()}-${fileName}`; // Уникальный ключ файла\\n  const params = {\\n    Bucket: process.env.R2_BUCKET,\\n    Key: key,\\n    Body: fileBuffer,\\n    ContentType: mimeType, // Важно для отдачи файла\\n  };\\n  const command = new PutObjectCommand(params);\\n  await this.r2.send(command); // Асинхронная загрузка\\n\\n  // Возвращаем URL для сохранения в БД. R2 позволяет прямые ссылки, если настроен публичный домен.\\n  // ИЛИ генерируем подписанный URL для ограниченного доступа (более безопасно).\\n  // Пример прямой ссылки (требует настройки Public Access URL в CF Dashboard):\\n  // const publicUrl = `${process.env.R2_ENDPOINT.replace('.r2.cloudflarestorage.com', '.r2.dev')}/${process.env.R2_BUCKET}/${key}`;\\n  // Для своего домена (предпочтительно):\\n  const fileUrl = `https://r2.brainmessenger.com/${key}`; // Ваш настроенный домен Cloudflare Workers/Pages\\n\\n  return fileUrl;\\n}\\n\\n//backend/src/chat/chat.service.ts (интеграция uploadFile)\\n// ... constructor с StorageService ...\\nasync sendFileMessage(chatId: string, userId: string, file: Express.Multer.File): Promise<Message> {\\n   // Опционально: обработка изображения перед загрузкой (см. DocOptimizationIn)\\n   // const processedFileBuffer = await this.imageProcessingService.processImage(file.buffer, 800, 600); // Пример\\n   const fileUrl = await this.storageService.uploadFile(file.buffer, file.originalname, file.mimetype);\\n\\n   // Создаем сообщение в БД со ссылкой на файл\\n   return this.prisma.message.create({\\n     data: {\\n       chatId,\\n       userId,\\n       content: '[File]', // Или другое обозначение файла\\n       fileUrl: fileUrl, // Сохраняем ссылку на файл в БД\\n       // fileMetadata: { type: file.mimetype, size: file.size }, // Опционально: сохранение метаданных в JSON поле или отдельной таблице\\n     },\\n   });\\n}\\n```",
          "result": "<strong>Результат:</strong> Файл надежно хранится в R2, ссылка на него доступна в БД для отображения в чате."
        },
        "sensitiveData": {
          "title": "Сценарий: Хранение конфиденциальных данных (например, зашифрованные метаданные):",
          "interaction": "<strong>Взаимодействие:</strong> При регистрации или обновлении профиля Backend шифрует чувствительные данные (например, резервные email, секретные вопросы) и сохраняет их в R2 в отдельном бакете или папке.",
          "code": "<strong>Пример кода (Backend Service):</strong>\\n```typescript\\n// backend/src/storage/storage.service.ts (продолжение)\\n// ... методы encrypt/decrypt ...\\n\\nasync storeSensitiveData(userId: string, sensitiveInfo: any): Promise<string> {\\n   const encryptedData = {};\\n   for (const key in sensitiveInfo) {\\n       if (sensitiveInfo.hasOwnProperty(key)) {\\n           const { encrypted, iv } = this.encrypt(JSON.stringify(sensitiveInfo[key])); // Шифруем каждое поле или весь объект\\n           encryptedData[key] = { encrypted, iv };\\n       }\\n   }\\n\\n   const key = `sensitive/${userId}/metadata.json`;\\n   const params = {\\n       Bucket: process.env.R2_BUCKET, // Или отдельный бакет для чувствительных данных\\n       Key: key,\\n       Body: JSON.stringify(encryptedData),\\n       ContentType: 'application/json',\\n   };\\n   const command = new PutObjectCommand(params);\\n   await this.r2.send(command);\\n   return `https://r2.brainmessenger.com/${key}`; // Ссылка для внутреннего использования\\n}\\n\\n// backend/src/user/user.service.ts (интеграция storeSensitiveData)\\n// ... constructor с StorageService ...\\nasync createUserWithSensitiveData(userData: any, sensitiveData: any) {\\n    // Создаем пользователя в БД\\n    const user = await this.prisma.user.create({ data: userData });\\n    // Сохраняем зашифрованные данные в R2\\n    const sensitiveDataUrl = await this.storageService.storeSensitiveData(user.id, sensitiveData);\\n    // Сохраняем ссылку на зашифрованные данные в БД (опционально)\\n    await this.prisma.user.update({\\n        where: { id: user.id },\\n        data: { sensitiveDataUrl: sensitiveDataUrl } // Добавить поле sensitiveDataUrl в схему Prisma\\n    });\\n    return user;\\n}\\n```",
          "result": "<strong>Результат:</strong> Конфиденциальные данные надежно зашифрованы и хранятся отдельно от основной БД в R2. Доступ к ним возможен только через Backend с использованием ключа шифрования."
        },
        "getFile": {
          "title": "Сценарий: Получение файла (для отображения или скачивания):",
          "interaction": "<strong>Взаимодействие:</strong> Frontend получает URL файла из метаданных сообщения (из Neon) → Frontend (или Backend, если требуется аутентификация/подписанные URL) использует этот URL для скачивания файла напрямую из R2.",
          "code": "<strong>Реализация:</strong> Если бакет R2 настроен с Public Access URL (через Cloudflare Workers/Pages), Frontend может обращаться напрямую. Если доступ ограничен, Backend может генерировать временные подписанные URL через `@aws-sdk/s3-request-presigner`.\\n```typescript\\n// backend/src/storage/storage.service.ts (продолжение)\\n// ... S3Client инициализация ...\\n\\n// Метод для генерации подписанного URL (более безопасный подход для приватных файлов)\\nasync getSignedFileUrl(fileKey: string): Promise<string> {\\n    const command = new GetObjectCommand({\\n        Bucket: process.env.R2_BUCKET,\\n        Key: fileKey,\\n    });\\n    // Сгенерировать подписанный URL, действительный, например, 60 секунд\\n    const signedUrl = await getSignedUrl(this.r2, command, { expiresIn: 60 });\\n    return signedUrl;\\n}\\n```"
        }
      },
      "errorHandling": {
        "title": "4.4. Обработка Ошибок Интеграции: Хранилище Активов",
        "forbidden": {
          "title": "403 Forbidden:",
          "cause": "Причина: Ошибка доступа к бакету R2. Неверные ключи доступа (`R2_ACCESS_KEY`, `R2_SECRET_KEY`), неверные разрешения токена, попытка доступа к приватному файлу без аутентификации/подписанного URL.",
          "solution": "Решение: Проверить переменные окружения, разрешения токена R2. Убедиться, что логика доступа (публичный URL vs подписанный URL) реализована корректно. Логировать ошибку."
        },
        "notFound": {
          "title": "404 Not Found:",
          "cause": "Причина: Файл отсутствует в R2. Неверный ключ файла (`Key`), файл был удален.",
          "solution": "Решение: Проверить ключ файла, который был сохранен в Neon. Убедиться, что файл действительно был загружен. Логировать ошибку."
        },
        "tooManyRequests": {
          "title": "429 Too Many Requests:",
          "cause": "Причина: Превышен лимит запросов к R2 API. Высокая частота запросов загрузки/скачивания.",
          "solution": "Решение: Внедрить Rate Limiting на Backend (см. Руководство по оптимизации). Оптимизировать логику работы с файлами."
        },
        "encryptionError": {
          "title": "Encryption/Decryption Error:",
          "cause": "Причина: Ошибка шифрования/дешифрования. Неверный ключ шифрования (`ENCRYPTION_KEY`), поврежденный IV, поврежденные зашифрованные данные.",
          "solution": "Решение: Убедиться, что используется правильный ключ (`ENCRYPTION_KEY`), который совпадает с ключом, использованным при шифровании. Проверить целостность данных и IV. Логировать критическую ошибку."
        }
      }
    },
    "neonR2Interaction": {
      "title": "5. Взаимодействие Neon и Cloudflare R2: Оптимизация Хранения Данных (Принцип 9, 12)",
      "description": "Мы используем Neon и R2 совместно, чтобы создать оптимизированную систему хранения данных, где каждый сервис выполняет свою лучшую функцию (Принцип 9).",
      "scenario": [
        "<strong>Neon (PostgreSQL):</strong> Хранит <strong>структурированные метаданные</strong>, которые часто запрашиваются и по которым выполняются сложные запросы (пользователи, чаты, текстовые сообщения, ссылки на файлы).",
        "<strong>Cloudflare R2:</strong> Хранит <strong>неструктурированные бинарные данные</strong> большого размера (файлы), которые реже запрашиваются и не требуют сложной логики выборки по содержимому).",
        "<strong>Сценарий комплексного взаимодействия:</strong>",
        "1. Пользователь отправляет файл через чат (Frontend -> Backend).",
        "2. Backend (`StorageService`) <strong>загружает файл в Cloudflare R2</strong> (используя S3 API). Получает URL файла (или ключ).",
        "3. Backend (`ChatService`) <strong>сохраняет метаданные сообщения в Neon через Prisma</strong>, включая полученный URL/ключ файла.",
        "4. Когда другой пользователь открывает чат, Backend (`ChatService`) <strong>получает список сообщений из Neon через Prisma</strong>, включая URL/ключи файлов.",
        "5. Frontend отображает список сообщений и использует URL/ключи для <strong>скачивания файлов напрямую из R2</strong> (или через Backend, если требуется аутентификация)."
      ],
      "advantagesTitle": "Преимущества такого разделения:",
      "advantages": [
        "<strong>Оптимизация производительности БД:</strong> PostgreSQL не \"засоряется\" большими бинарными данными, что улучшает скорость текстовых запросов (Принцип 9).",
        "<strong>Снижение стоимости:</strong> R2 предлагает очень выгодные тарифы для хранения больших объемов данных без платы за исходящий трафик, что <strong>прагматично</strong> (Принцип 12) и способствует созданию <strong>актива</strong> (Принцип 10).",
        "<strong>Масштабируемость:</strong> Каждый сервис масштабируется независимо в соответствии со своим типом нагрузки (Neon для транзакций, R2 для объема/трафика файлов).",
        "<strong>Надежность:</strong> Разделение ответственности между сервисами повышает общую отказоустойчивость системы."
      ]
    },
    "otherIntegrations": {
      "title": "6. Другие Интеграции: Расширение Функционала Системы (Принцип 2, 12)",
      "description": "Эти интеграции добавляют <strong>ценность</strong> (Принцип 2) и используют <strong>прагматичные, готовые решения</strong> (Принцип 12).",
      "firebase": {
        "title": "6.1. Firebase (Push-уведомления)",
        "purpose": "Назначение: Мгновенная доставка уведомлений о новых сообщениях, звонках и системных событиях пользователям мобильных приложений.",
        "role": "Роль: <strong>Критически важный компонент системы уведомлений</strong> (Принцип 9) для поддержания вовлеченности пользователей и оперативного информирования (Принцип 2).",
        "configuration": "Конфигурация: Переменная окружения: `FIREBASE_CREDENTIALS_PATH` (путь к JSON-файлу учетных данных сервисного аккаунта Firebase). <strong>Храните этот файл безопасно!</strong>",
        "example": "Используется библиотека `firebase-admin` в Backend NestJS. Пример использования: Отправка уведомления при получении нового сообщения (см. Руководство по оптимизации для батчинга и тем)."
      },
      "stripe": {
        "title": "6.2. Stripe (Платежи)",
        "purpose": "Назначение: Обработка подписок на Premium-функционал BrainMessenger.",
        "role": "Роль: <strong>Финансовый рычаг</strong> для поддержки развития проекта (Принцип 10: Создание Богатства) и предоставления дополнительной <strong>ценности</strong> (Принцип 2) премиум-пользователям.",
        "configuration": "Конфигурация: Переменная окружения: `STRIPE_SECRET_KEY`.",
        "example": "Используется библиотека `stripe` в Backend NestJS. Пример использования: Создание сессии оплаты при попытке оформить подписку. Обработка вебхуков для подтверждения успешной оплаты."
      },
      "gmailApi": {
        "title": "6.3. Gmail API (Отправка Email)",
        "purpose": "Назначение: Отправка транзакционных email, таких как коды подтверждения для регистрации и двухфакторной аутентификации (2FA), уведомления о сбросе пароля.",
        "role": "Роль: <strong>Критически важный компонент системы аутентификации и безопасности</strong> (Принцип 9, 5).",
        "configuration": "Конфигурация: Требует настройки сервисного аккаунта Google Cloud и получения учетных данных (см. Техническую документацию, раздел 10.1). Переменные окружения для учетных данных сервисного аккаунта или API-ключей.",
        "example": "Пример использования: Вызов API для отправки письма с кодом подтверждения после ввода email при регистрации или включении 2FA (см. Спецификацию API, раздел 2.4)."
      }
    },
    "recommendations": {
      "title": "7. Рекомендации по Интеграциям: Поддержание Здоровья Системы (Принцип 3, 5, 9)",
      "intro": "Чтобы интеграции оставались <strong>надежными, безопасными и эффективными</strong> (Принцип 3, 9), следуйте этим рекомендациям, связанным с поддержанием \"здоровья\" системы (Принцип 5, применительно к технике):",
      "security": {
        "title": "Безопасность:",
        "points": [
          "<strong>Никогда не коммитьте ключи и секреты в Git.</strong> Используйте переменные окружения и системы управления секретами в продакшен-окружении (например, Kubernetes Secrets, HashiCorp Vault).",
          "Регулярно проводите <strong>ротацию API-токенов</strong> (R2, Firebase, Gmail, Stripe) для повышения безопасности.",
          "Используйте <strong>принцип минимальных привилегий</strong> при создании API-токенов: давайте им только те разрешения, которые действительно необходимы."
        ]
      },
      "scaling": {
        "title": "Масштабирование:",
        "points": [
          "<strong>Мониторьте использование ресурсов</strong> (место в Neon/R2, запросы к API Firebase/Stripe) через консоли соответствующих сервисов. Будьте готовы перейти на платный тариф при росте нагрузки (Принцип 8, 12).",
          "Используйте <strong>оптимизационные подходы</strong> (например, батчинг запросов к Firebase, индексирование в Neon, см. Руководство по оптимизации), чтобы отложить необходимость перехода на более дорогие тарифы."
        ]
      },
      "monitoring": {
        "title": "Мониторинг и Логирование:",
        "points": [
          "Настройте <strong>логирование ошибок интеграций</strong> в NestJS (Winston, Sentry).",
          "Используйте <strong>системы мониторинга</strong> (Prometheus/Grafana) для отслеживания метрик запросов к внешним сервисам (задержки, количество ошибок) — это часть <strong>Кайдзен</strong> (Принцип 9), позволяющая выявлять проблемы на ранней стадии."
        ]
      },
      "errorHandling": {
        "title": "Обработка Ошибок:",
        "points": [
          "Реализуйте <strong>грамотную обработку ошибок</strong> от внешних сервисов на Backend. Логируйте их подробно.",
          "Для критически важных операций (например, регистрация, платежи) предусмотрите механизмы <strong>повторных попыток (retries)</strong> или <strong>компенсирующих действий</strong> (например, отметка платежа как незавершенного) при временных сбоях внешних сервисов."
        ]
      },
      "documentation": {
        "title": "Документация:",
        "content": "Поддерживайте эту документацию в актуальном состоянии, отражая изменения в используемых сервисах или добавлении новых интеграций (Принцип 1: Обучение, Принцип 9: Система)."
      }
    }
  },
  "optimizationGuide": {
      "title": "Руководство по Оптимизации BrainMessenger (Принцип Кайдзен в Действии)",
      "subtitle": "Введение: Оптимизация как Непрерывный Процесс Улучшения",
      "introduction": {
        "title": "1. Введение: Оптимизация как Непрерывный Процесс Улучшения",
        "description": "Этот документ подробно описывает подходы, инструменты и техники, которые мы используем для оптимизации производительности BrainMessenger. Оптимизация — это не одноразовая задача, а <strong>непрерывный процесс улучшения</strong> (Принцип 1, 9: Кайдзен), который позволяет нам обеспечить <strong>высокое качество, надежность и масштабируемость</strong> (Принцип 3, 8) приложения.",
        "goalTitle": "Цель:",
        "goalContent": "Идентифицировать и устранять узкие места в производительности на всех уровнях системы (Frontend, Backend, База данных, Инфраструктура), чтобы BrainMessenger оставался <strong>быстрым, отзывчивым и эффективным</strong> (Принцип 2) даже при значительной нагрузке (цель — 1 миллион активных пользователей), поддерживая <strong>здоровье системы</strong> (Принцип 5, применительно к технике).",
        "audienceTitle": "Аудитория:",
        "audienceContent": "Backend, Frontend, Mobile, Desktop и DevOps разработчики, сфокусированные на производительности и масштабировании.",
        "principlesTitle": "Принципы, которыми руководствуется оптимизация:",
        "principles": [
          "<strong>Система и Оптимизация (Принцип 9: Кайдзен):</strong> Оптимизация является ключевым аспектом нашей системы разработки. Используется цикличный подход: Измерение → Анализ → Улучшение → Проверка.",
          "<strong>Качество > Количество (Принцип 3):</strong> Лучше иметь несколько критически важных оптимизаций, чем много мелких, не дающих значительного эффекта.",
          "<strong>Прагматизм и Реализм (Принцип 12):</strong> Оптимизируем то, что действительно влияет на производительность и пользовательский опыт, основываясь на реальных данных, а не на догадках.",
          "<strong>Постоянное Обучение (Принцип 1):</strong> Изучение новых техник и инструментов оптимизации, анализ результатов и уроков.",
          "<strong>Настойчивость (Принцип 13):</strong> Оптимизация может быть сложной. Требуется упорство для выявления и решения глубоких проблем производительности.",
          "<strong>Здоровье как Фундамент (Принцип 5):</strong> Оптимизация системы (например, снижение потребления памяти/CPU) напрямую влияет на \"здоровье\" серверов и устройств пользователей.",
          "<strong>Внешняя Экспертиза (Принцип 14):</strong> Использование стандартных инструментов (Prometheus, Grafana, V8 Profiler), изучение опыта других команд (Google, Next.js и т.д.)."
        ]
      },
      "generalPrinciple": {
        "title": "2. Общий Принцип Оптимизации (Цикл Кайдзен)",
        "intro": "Наш подход к оптимизации следует <strong>циклу Кайдзен (Принцип 9)</strong>:",
        "step1": {
          "title": "1. Измерение (Measure):",
          "content": "Соберите данные о производительности. Используйте инструменты мониторинга (Prometheus, Sentry), профилирования (V8 Profiler), анализа бандлов (Webpack Bundle Analyzer, `@next/bundle-analyzer`)."
        },
        "step2": {
          "title": "2. Анализ (Analyze):",
          "content": "Определите <strong>узкие места (bottlenecks)</strong> на основе собранных данных. Где система тратит больше всего времени или ресурсов?"
        },
        "step3": {
          "title": "3. Улучшение (Improve):",
          "content": "Примените конкретные техники оптимизации, описанные в этом руководстве, для устранения выявленных узких мест."
        },
        "step4": {
          "title": "4. Проверка (Verify):",
          "content": "Снова измерьте производительность после внесенных изменений. Убедитесь, что оптимизация дала ожидаемый эффект и не вызвала регрессий (не ухудшила другие аспекты)."
        },
        "step5": {
          "title": "5. Повторение:",
          "content": "Производительность может меняться с ростом нагрузки и функционала. Повторяйте цикл Кайдзен непрерывно."
        }
      },
      "imageProcessing": {
        "title": "3. Оптимизация Обработки Изображений: Эффективность и Скорость (Принцип 9, 2)",
        "intro": "Обработка изображений может быть ресурсоемкой. <strong>Оптимизация этого процесса напрямую влияет на скорость загрузки контента и отзывчивость приложения</strong> (Принцип 2: Ценность).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`sharp` (на базе `libvips`). Выбран как <strong>прагматичное</strong> (Принцип 12) и <strong>высокопроизводительное</strong> (Принцип 9) решение для Node.js.",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": "Изменение размера, сжатие, конвертация формата для аватаров, изображений в чатах.",
        "keyTechniqueTitle": "Ключевая техника:",
        "keyTechniqueContent": "<strong>Асинхронная обработка</strong> в фоновом режиме через Kafka.",
        "implementationStepsTitle": "Шаги по внедрению (Backend):",
        "step1": {
          "title": "1. Установите `sharp`:",
          "content": "Убедитесь, что `libvips` установлен в вашей операционной системе или Docker-образе.",
          "code": "```bash\\nnpm install sharp\\n```"
        },
        "step2": {
          "title": "2. Создайте сервис обработки изображений:",
          "content": "Инкапсулируйте логику в отдельном сервисе (часть <strong>системы</strong> - Принцип 9).",
          "code": "```typescript\\n// backend/src/image-processing/image-processing.service.ts\\nimport { Injectable } from '@nestjs/common';\\nimport sharp from 'sharp';\\n\\n@Injectable()\\nexport class ImageProcessingService {\\n  // Метод для изменения размера, сжатия и конвертации в WebP\\n  async processImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n    // resize({ width, height, withoutEnlargement: true }) - избегаем увеличения, если исходник меньше\\n    // webp({ quality: 80 }) - сжатие в формат WebP (хорошее сжатие при сохранении качества)\\n    // withMetadata({ orientation: true }) - сохраняем ориентацию из EXIF, остальное удаляем (экономия размера - Принцип 9)\\n    return sharp(buffer)\\n      .resize(width, height, { withoutEnlargement: true })\\n      .webp({ quality: 80 })\\n      .withMetadata({ orientation: true })\\n      .toBuffer();\\n  }\\n\\n  // Метод для простого изменения размера\\n  async resizeImage(buffer: Buffer, width: number, height?: number): Promise<Buffer> {\\n       return sharp(buffer)\\n           .resize(width, height, { withoutEnlargement: true })\\n           .toBuffer();\\n  }\\n\\n   // Метод для конвертации в определенный формат\\n   async convertToFormat(buffer: Buffer, format: keyof sharp.Format): Promise<Buffer> {\\n       return sharp(buffer).toFormat(format).toBuffer();\\n   }\\n}\\n```"
        },
        "step3": {
          "title": "3. Интеграция с загрузкой файлов (Backend Controller/Service):",
          "content": "",
          "code": "```typescript\\n// backend/src/upload/upload.controller.ts (пример обработки загрузки аватара)\\nimport { Controller, Post, UploadedFile, UseInterceptors, Body, Inject } from '@nestjs/common';\\nimport { FileInterceptor } from '@nestjs/platform-express';\\nimport { ImageProcessingService } from '../image-processing/image-processing.service';\\nimport { StorageService } from '../storage/storage.service';\\nimport { UserService } from '../user/user.service';\\n\\n@Controller('upload')\\nexport class UploadController {\\n  constructor(\\n    private imageProcessingService: ImageProcessingService,\\n    private storageService: StorageService,\\n    private userService: UserService,\\n    // ... инъекция Kafka продюсера для асинхронной обработки\\n  ) {}\\n\\n  @Post('avatar')\\n  @UseInterceptors(FileInterceptor('file')) // 'file' - имя поля формы\\n  async uploadAvatar(@UploadedFile() file: Express.Multer.File, @Body('userId') userId: string) {\\n    // Оптимизация: Обработка изображения перед загрузкой в R2\\n    const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 300, 300); // Изменить размер и сжать\\n    const fileName = `avatars/${userId}-${Date.now()}.webp`; // Уникальное имя файла в папке avatars\\n    const mimeType = 'image/webp'; // Соответствует формату WebP\\n\\n    // Загрузка обработанного файла в Cloudflare R2\\n    const avatarUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n    // Обновление ссылки на аватар в профиле пользователя в Neon\\n    await this.userService.updateUserAvatar(userId, avatarUrl);\\n\\n    // Возвращаем URL аватара клиенту\\n    return { avatarUrl };\\n  }\\n\\n  @Post('chat-image')\\n  @UseInterceptors(FileInterceptor('file'))\\n  async uploadChatImage(@UploadedFile() file: Express.Multer.File, @Body('chatId') chatId: string, @Body('userId') userId: string) {\\n      // Отправка задачи на обработку изображения в Kafka для асинхронной обработки (Принцип 9)\\n      const taskPayload = { fileBuffer: file.buffer.toString('base64'), fileName: file.originalname, mimeType: file.mimetype, chatId, userId };\\n      // Предполагается, что у вас есть Kafka продюсер сервис\\n      // await this.kafkaProducerService.sendMessage('image-processing-topic', JSON.stringify(taskPayload));\\n\\n      // Немедленный ответ клиенту, что файл принят в обработку\\n      return { status: 'processing', originalFileName: file.originalname };\\n\\n      // ИЛИ, если синхронная обработка приемлема для небольших файлов:\\n      /*\\n      const processedImageBuffer = await this.imageProcessingService.processImage(file.buffer, 800); // Изменить размер\\n      const fileName = `chat-images/${chatId}-${Date.now()}.webp`;\\n      const mimeType = 'image/webp';\\n      const imageUrl = await this.storageService.uploadFile(processedImageBuffer, fileName, mimeType);\\n\\n      // Создание сообщения типа 'image' в чате\\n      // await this.chatService.sendImageMessage(chatId, userId, imageUrl);\\n\\n      return { imageUrl };\\n      */\\n  }\\n}\\n```"
        },
        "step4": {
          "title": "4. Асинхронность через Kafka (для тяжелых задач):",
          "content": "Для обработки изображений в чатах (которые могут быть большими) используйте <strong>Kafka</strong> (см. раздел 8) для <strong>асинхронной обработки</strong>. Backend быстро принимает файл от клиента и ставит задачу в очередь Kafka. Отдельный воркер (consumer Kafka) забирает задачу, обрабатывает изображение с помощью `sharp`, загружает в R2 и только после этого создает сообщение в чате через API. Это <strong>снижает время ответа API</strong> (Принцип 9) и улучшает пользовательский опыт."
        }
      },
      "dbOptimization": {
        "title": "4. Оптимизация Базы Данных (Neon/PostgreSQL): Ускорение Доступа к Данным (Принцип 9, 8)",
        "intro": "База данных часто становится узким местом. Оптимизация запросов и структуры БД критически важна для <strong>долгосрочной производительности</strong> (Принцип 8) и <strong>эффективности системы</strong> (Принцип 9).",
        "platformTitle": "Платформа:",
        "platformContent": "Neon (управляемый PostgreSQL).",
        "toolTitle": "Инструмент:",
        "toolContent": "Prisma ORM.",
        "analysisToolTitle": "Инструмент анализа:",
        "analysisToolContent": "`EXPLAIN ANALYZE` в SQL-клиенте Neon или `prisma.queryRaw` с `EXPLAIN ANALYZE`.",
        "monitoringToolTitle": "Инструмент мониторинга:",
        "monitoringToolContent": "Prometheus + `postgres_exporter` (см. раздел 14).",
        "indexing": {
          "title": "4.1. Индексация: Ускорение Поиска и Фильтрации",
          "intro": "Индексы позволяют базе данных быстрее находить нужные строки.",
          "whenTitle": "Когда использовать:",
          "whenContent": "На полях, которые часто используются в `WHERE`, `JOIN`, `ORDER BY`.",
          "applicationAreasTitle": "Области применения в BrainMessenger:",
          "applicationAreasContent": "`userId`, `chatId`, `createdAt` (в таблице `Message`), `email` (в таблице `User`), поля для поиска.",
          "prismaTitle": "Реализация (Prisma):",
          "prismaContent": "Добавляйте `@index` в `schema.prisma`.",
          "prismaCode": "```prisma\\n// schema.prisma\\nmodel Message {\\n  id        String   @id @default(cuid())\\n  content   String\\n  createdAt DateTime @default(now()) @map(\\\"created_at\\\") // Пример @map для snake_case в БД\\n  chatId    String @map(\\\"chat_id\\\")\\n  userId    String @map(\\\"user_id\\\")\\n  chat      Chat     @relation(fields: [chatId], references: [id])\\n  user      User     @relation(fields: [userId], references: [id])\\n\\n  // Комбинированный индекс для быстрых запросов сообщений в чате по времени\\n  @@index([chatId, createdAt])\\n  // Индекс для быстрого получения сообщений по пользователю (например, для статистики)\\n  @@index([userId])\\n  // Индекс для поиска по содержимому (если требуется полнотекстовый поиск - рассмотреть tsearch)\\n  // @@index([content]) // Только для простых фильтров LIKE\\n}\\n\\nmodel User {\\n    id    String @id @default(cuid())\\n    email String @unique // Уникальный индекс для быстрого поиска по email (логин, регистрация)\\n    name  String\\n    // ... другие поля\\n}\\n\\nmodel Chat {\\n   id          String @id @default(cuid())\\n   lastMessageAt DateTime? @map(\\\"last_message_at\\\") // Для сортировки чатов (нужен индекс)\\n   // ... другие поля\\n   @@index([lastMessageAt]) // Индекс для сортировки списка чатов\\n}\\n```",
          "applicationTitle": "Применение:",
          "applicationContent": "После изменения `schema.prisma` выполните миграцию (`npx prisma migrate dev`)."
        },
        "queryOptimization": {
          "title": "4.2. Оптимизация Запросов (Prisma): Пишем Эффективный Код Взаимодействия с БД",
          "intro": "",
          "selectFieldsTitle": "Выбирайте только нужные поля (`select`):",
          "selectFieldsContent": "Не запрашивайте `SELECT *`. Указывайте поля, которые вам действительно нужны. Это уменьшает объем данных, передаваемых по сети и обрабатываемых БД.",
          "selectFieldsCode": "```typescript\\n// Плохо\\nconst user = await prisma.user.findUnique({ where: { id: userId } }); // Выберет все поля\\n\\n// Хорошо (если нужен только email и name)\\nconst user = await prisma.user.findUnique({\\n  where: { id: userId },\\n  select: {\\n    email: true,\\n    name: true,\\n  },\\n});\\n```",
          "nPlus1Title": "Избегайте N+1 проблем (`include`):",
          "nPlus1Content": "Если вам нужны связанные данные (например, автор сообщения при получении списка сообщений), используйте `include` или `select` со вложенными полями вместо выполнения отдельного запроса для каждого элемента.",
          "nPlus1Code": "```typescript\\n// Плохо (N+1 проблема - отдельный запрос за каждым пользователем)\\nconst messages = await prisma.message.findMany({ where: { chatId: chatId } });\\nfor (const message of messages) {\\n  const sender = await prisma.user.findUnique({ where: { id: message.userId } });\\n  // ... использовать sender\\n}\\n\\n// Хорошо (используем include для получения автора сообщения одним запросом)\\nconst messagesWithSender = await prisma.message.findMany({\\n  where: { chatId: chatId },\\n  include: {\\n    user: { // Включаем данные пользователя, связанного с сообщением через поле 'user' в модели Message\\n      select: { id: true, name: true, avatarUrl: true } // Выбираем только нужные поля пользователя\\n    },\\n  },\\n  orderBy: { createdAt: 'asc' }, // Пример: сообщения в хронологическом порядке\\n  take: 50, // Пример: пагинация\\n});\\n```",
          "paginationTitle": "Пагинация (`skip`, `take`, `cursor`):",
          "paginationContent": "Для получения больших списков (сообщения в чате, список чатов) используйте пагинацию, чтобы не загружать все данные сразу. `cursor`-пагинация предпочтительнее для бесконечной прокрутки.",
          "paginationCode": "```typescript\\n// Пример пагинации с take и skip\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    skip: (page - 1) * pageSize, // Пропустить N сообщений\\n    take: pageSize, // Взять M сообщений\\n});\\n\\n// Пример Cursor-based пагинации (для \\\"показать еще\\\")\\nconst messages = await prisma.message.findMany({\\n    where: { chatId: chatId },\\n    orderBy: { createdAt: 'asc' },\\n    cursor: { id: lastMessageId }, // Начать после последнего сообщения\\n    skip: 1, // Пропустить само последнее сообщение\\n    take: pageSize,\\n});\\n```"
        },
        "prismaAccelerate": {
          "title": "4.3. Prisma Accelerate: Глобальный Кэш и Пул Соединений",
          "intro": "Prisma Accelerate предоставляет глобальную сеть серверов (Edge locations), которые кэшируют результаты запросов и управляют пулом соединений к вашей БД Neon.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для снижения задержки запросов (latency) для пользователей по всему миру и оптимизации использования пула соединений БД.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Настраивается в консоли Prisma. Ваша `DATABASE_URL` заменяется на URL Prisma Accelerate."
        },
        "materializedViews": {
          "title": "4.4. Материализованные Представления: Кэширование Сложных Агрегаций",
          "intro": "Материализованные представления — это по сути кэшированные результаты сложных запросов или агрегаций (например, количество сообщений в чате, последние активные пользователи в группе). Они хранятся на диске и могут быть быстро прочитаны.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для запросов, которые выполняются часто, но требуют сложных вычислений (JOINs, GROUP BY, агрегатные функции) над большими таблицами, и данные в которых не должны быть абсолютно актуальными каждую миллисекунду.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Статистика чатов (общее количество сообщений, участников), списки \"топ\" пользователей (например, по количеству отправленных сообщений).",
          "implementationTitle": "Реализация (SQL, через Prisma `queryRaw` или SQL-клиент Neon):",
          "implementationContent": "```sql\\n-- Создать материализованное представление для подсчета сообщений в каждом чате\\nCREATE MATERIALIZED VIEW chat_message_counts AS\\nSELECT\\n    \\\"chatId\\\",\\n    COUNT(*) as \\\"messageCount\\\"\\nFROM \\\"Message\\\"\\nGROUP BY \\\"chatId\\\";\\n\\n-- Создать индекс на представлении для быстрого поиска по chatId (необязательно, но часто полезно)\\nCREATE INDEX idx_chat_message_counts_chat_id ON chat_message_counts (\\\"chatId\\\");\\n```",
          "updateTitle": "Обновление:",
          "updateContent": "Материализованные представления нужно <strong>периодически обновлять</strong>, чтобы отразить изменения в базовых таблицах. Это делается командой `REFRESH MATERIALIZED VIEW <view_name>;`. Частота обновления зависит от того, насколько актуальными должны быть данные (например, раз в час, раз в день).",
          "updateCode": "```sql\\n-- Обновить представление (может блокировать чтение во время выполнения)\\nREFRESH MATERIALIZED VIEW chat_message_counts;\\n\\n-- Обновить представление без блокировки чтения (для больших представлений)\\nREFRESH MATERIALIZED VIEW CONCURRENTLY chat_message_counts; -- Требует уникального индекса\\n```",
          "usageTitle": "Использование в Prisma:",
          "usageContent": "Запрашивайте как обычную таблицу.",
          "usageCode": "```typescript\\nconst chatStats = await prisma.chatMessageCounts.findMany({\\n  select: { chatId: true, messageCount: true },\\n  where: { chatId: 'some-chat-id' },\\n});\\n```"
        },
        "partitioning": {
          "title": "4.5. Партиционирование Таблиц: Разделение Больших Объемов Данных",
          "intro": "Партиционирование физически разделяет очень большие таблицы (например, `Message`) на более мелкие части (партиции) на основе значения в определенном столбце (например, `createdAt` или `chatId`).",
          "whenTitle": "Когда использовать:",
          "whenContent": "Когда таблица становится настолько большой (миллиарды строк), что индексы уже не справляются, и запросы начинают замедляться из-за необходимости сканировать слишком много данных.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Таблица `Message` — идеальный кандидат для партиционирования по времени создания (`createdAt`) или по ID чата (`chatId`).",
          "implementationTitle": "Реализация (SQL, через Prisma `queryRaw` или SQL-клиент Neon):",
          "implementationContent": "PostgreSQL поддерживает нативное партиционирование.",
          "implementationCode": "```sql\\n-- Создать главную партиционированную таблицу по диапазону дат\\nCREATE TABLE messages (\\n    id TEXT NOT NULL,\\n    content TEXT NOT NULL,\\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL,\\n    chat_id TEXT NOT NULL,\\n    user_id TEXT NOT NULL,\\n    PRIMARY KEY (id, created_at) -- Ключ партиционирования должен быть частью первичного ключа\\n) PARTITION BY RANGE (created_at); -- Партиционируем по диапазону поля created_at\\n\\n-- Создать партиции (например, по месяцам)\\nCREATE TABLE messages_2025_03 PARTITION OF messages\\n    FOR VALUES FROM ('2025-03-01 00:00:00+00') TO ('2025-04-01 00:00:00+00');\\n\\nCREATE TABLE messages_2025_04 PARTITION OF messages\\n    FOR VALUES FROM ('2025-04-01 00:00:00+00') TO ('2025-05-01 00:00:00+00');\\n\\n-- ... создавать новые партиции по мере необходимости (автоматически или вручную)\\n\\n-- Создать индексы для партиционированной таблицы (применяются ко всем партициям)\\nCREATE INDEX ON messages (\\\"chat_id\\\", \\\"created_at\\\");\\nCREATE INDEX ON messages (\\\"user_id\\\");\\n```",
          "advantagesTitle": "Преимущества:",
          "advantagesContent": "Запросы, включающие фильтр по ключу партиционирования (например, `WHERE created_at BETWEEN ...`), будут сканировать только нужные партиции, что значительно ускоряет их выполнение. Управление старыми данными (удаление) становится проще (можно просто удалить старые партиции).",
          "prismaRelationTitle": "Связь с Prisma:",
          "prismaRelationContent": "Prisma работает с партиционированной таблицей как с обычной."
        }
      },
      "graphqlOptimization": {
        "title": "5. Оптимизация GraphQL API (NestJS + Prisma): Эффективная Передача Данных",
        "intro": "GraphQL сам по себе является инструментом <strong>оптимизации</strong> (Принцип 9) по сравнению с REST (клиент запрашивает только нужные данные). Однако и его можно оптимизировать.",
        "analysisToolTitle": "Инструмент анализа:",
        "analysisToolContent": "`graphql-query-complexity` для защиты от сложных запросов.",
        "dataloader": {
          "title": "5.1. DataLoader: Решение Проблемы N+1 в GraphQL",
          "intro": "DataLoader — это утилита, которая помогает решить проблему N+1 запросов при работе с графами данных. Если у вас есть список объектов, и для каждого объекта нужно подтянуть связанный с ним объект (например, список сообщений и для каждого сообщения его автора), DataLoader соберет все ID связанных объектов и сделает один пакетный запрос к БД.",
          "whenTitle": "Когда использовать:",
          "whenContent": "В резолверах GraphQL, когда вам нужно получить связанные объекты для списка родительских объектов.",
          "applicationAreasTitle": "Области применения:",
          "applicationAreasContent": "Получение данных автора для каждого сообщения в чате, получение списка участников для каждого чата в списке чатов пользователя.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Создайте отдельные DataLoader для каждого типа объекта, который нужно подтягивать. Интегрируйте их в контекст GraphQL запроса.",
          "implementationCode": "```typescript\\n// backend/src/graphql/loaders/user.loader.ts\\nimport { Injectable, Scope } from '@nestjs/common';\\nimport DataLoader from 'dataloader';\\nimport { PrismaService } from 'nestjs-prisma';\\nimport { User } from '@prisma/client'; // Импорт модели Prisma\\n\\n// Scope.REQUEST - важно, чтобы DataLoader был уникален для каждого запроса GraphQL\\n@Injectable({ scope: Scope.REQUEST })\\nexport class UserLoader {\\n  private loader: DataLoader<string, User>;\\n\\n  constructor(private prisma: PrismaService) {\\n    // Создаем новый DataLoader. Функция batchLoadFn принимает массив ключей (user IDs)\\n    this.loader = new DataLoader<string, User>(\\n      async (ids: readonly string[]) => {\\n        // Выполняем ОДИН запрос к БД, чтобы получить ВСЕх пользователей по их ID\\n        const users = await this.prisma.user.findMany({\\n          where: {\\n            id: { in: Array.from(ids) }, // Array.from(ids) для совместимости с Prisma\\n          },\\n        });\\n\\n        // Важно: Вернуть массив результатов, упорядоченный по исходному массиву ids\\n        const userMap = new Map(users.map(user => [user.id, user]));\\n        return ids.map(id => userMap.get(id)); // Возвращаем пользователей в том же порядке, что и запросили\\n      },\\n      { cache: true } // Включаем кэширование внутри запроса GraphQL\\n    );\\n  }\\n\\n  // Метод для загрузки одного пользователя по ID\\n  load(id: string): Promise<User> {\\n    return this.loader.load(id);\\n  }\\n\\n  // Метод для загрузки списка пользователей по ID\\n  loadMany(ids: string[]): Promise<(Error | User)[]> {\\n      return this.loader.loadMany(ids);\\n  }\\n}\\n```\\nИнтегрируйте лоадеры в контекст GraphQL (`backend/src/graphql/graphql.module.ts` или `app.module.ts`):\\n```typescript\\n// backend/src/graphql/graphql.module.ts\\nimport { Module } from '@nestjs/common';\\nimport { GraphQLModule } from '@nestjs/graphql';\\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\\nimport { UserLoader } from './loaders/user.loader'; // Импорт лоадера\\n// ... другие импорты резолверов и модулей\\n\\n@Module({\\n  imports: [\\n    GraphQLModule.forRoot<ApolloDriverConfig>({\\n      driver: ApolloDriver,\\n      // ... другие настройки GraphQL (schema path, context, etc.)\\n      context: ({ req, connection }) => {\\n        // Создаем контекст для каждого запроса\\n        const context = { req }; // Добавляем объект запроса\\n         if (connection) {\\n           // Для WebSocket (подписки)\\n           // context.loaders = new Loaders(); // Если лоадеры создаются здесь\\n         } else {\\n           // Для HTTP запросов (queries/mutations)\\n           // Создаем лоадеры и добавляем их в контекст\\n           context.loaders = {\\n              userLoader: new UserLoader(/* зависимости */), // Нужно инжектить PrismaService\\n              // ... другие лоадеры\\n           };\\n           // Пример инъекции зависимостей в лоадер (может потребовать FactoryProvider)\\n           // context.loaders = {\\n           //     userLoader: req.loaders.userLoader, // Если используете Request-scoped провайдеры NestJS\\n           // };\\n         }\\n        return context;\\n      },\\n      // plugins: [complexityPlugin], // Плагин для анализа сложности запросов\\n    }),\\n    // ... импорт других модулей\\n  ],\\n   providers: [UserLoader], // Добавляем лоадер как провайдер (для Request scope)\\n})\\nexport class GraphqlModule {}\\n```",
          "usageTitle": "Используйте лоадеры в резолверах:",
          "usageContent": "",
          "usageCode": "```typescript\\n// backend/src/message/message.resolver.ts\\nimport { Resolver, ResolveField, Parent, Context } from '@nestjs/graphql';\\nimport { Message } from '@prisma/client'; // Импорт модели Prisma\\nimport { UserLoader } from '../graphql/loaders/user.loader'; // Импорт лоадера\\n\\n@Resolver('Message') // Указываем GraphQL тип, к которому относится резолвер\\nexport class MessageResolver {\\n  @ResolveField('user') // Определяем резолвер для поля 'user' в типе Message\\n  async resolveUser(@Parent() message: Message, @Context() context: any) {\\n    // Используем userLoader из контекста для загрузки пользователя по message.userId\\n    // DataLoader автоматически соберет все message.userId в текущем запросе и загрузит их батчем\\n    return context.loaders.userLoader.load(message.userId);\\n  }\\n}\\n```"
        },
        "queryComplexityAnalysis": {
          "title": "5.2. Анализ Сложности Запросов: Защита от \"Тяжелых\" Запросов",
          "intro": "GraphQL позволяет клиенту запрашивать данные произвольной вложенности, что может привести к очень \"тяжелым\" запросам, сильно нагружающим сервер и БД.",
          "toolTitle": "Инструмент:",
          "toolContent": "`graphql-query-complexity`.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Всегда включайте защиту от сложности в продакшене.",
          "principleTitle": "Принцип работы:",
          "principleContent": "Плагин анализирует запрос до его выполнения и вычисляет его \"сложность\" (например, как сумму \"стоимости\" каждого поля). Если сложность превышает заданный порог, запрос отклоняется.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Настройте плагин в NestJS GraphQLModule (см. Руководство по разработке)."
        },
        "persistedQueries": {
          "title": "5.3. Persisted Queries: Кэширование Запросов на Уровне Сети",
          "intro": "Persisted Queries позволяют клиенту отправлять на сервер не полный текст GraphQL запроса, а только его хэш. Сервер по этому хэшу находит полный запрос (если он ему знаком) и выполняет его.",
          "whyTitle": "Почему:",
          "whyContent": "Уменьшает объем данных, передаваемых по сети, что ускоряет запросы, особенно на мобильных устройствах. Улучшает эффективность кэширования на CDN.",
          "whenTitle": "Когда использовать:",
          "whenContent": "Для часто повторяющихся запросов из клиента.",
          "implementationTitle": "Реализация:",
          "implementationContent": "Требует поддержки как на стороне клиента (Apollo Client поддерживает), так и на стороне сервера (Apollo Server поддерживает). На сервере нужно хранить соответствие хэшей и запросов (например, в Redis)."
        }
      },
      "backendLogicOptimization": {
        "title": "6. Оптимизация Backend Логики (NestJS): Эффективность Кода",
        "intro": "",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Профилирование Node.js (V8 Profiler), обнаружение утечек памяти (`heapdump`).",
        "whenTitle": "Когда использовать:",
        "whenContent": "Для выявления \"горячих\" участков кода, потребляющих много CPU или памяти, и диагностики проблем с памятью.",
        "processTitle": "Процесс:",
        "processContent": "Используйте инструменты профилирования для <strong>измерения</strong> (Шаг 1 Кайдзен). Анализируйте результаты (Шаг 2). Вносите изменения в код (Шаг 3). Повторите (Шаг 4).",
        "recommendationsTitle": "Рекомендации:",
        "recommendationsContent": "Избегайте синхронных операций, блокирующих основной поток Node.js. Используйте асинхронные API. Оптимизируйте циклы, работу с большими массивами/объектами."
      },
      "caching": {
        "title": "7. Кэширование (Redis): Снижение Нагрузки на БД и Ускорение (Принцип 9)",
        "intro": "Кэширование позволяет хранить часто запрашиваемые данные в быстрой памяти (Redis), чтобы не обращаться к более медленной БД (Neon) при каждом запросе. Это ключевой <strong>рычаг</strong> для повышения <strong>эффективности системы</strong> (Принцип 9).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`ioredis`, `@nestjs/cache-manager`, `cache-manager-redis-store`.",
        "patternTitle": "Pаттерн:",
        "patternContent": "Cache-Aside (чтение из кэша, если нет — чтение из БД и запись в кэш).",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": "Часто запрашиваемые, относительно редко изменяющиеся данные (профили пользователей, настройки приложения, результаты сложных запросов/агрегаций, материализованных представлений).",
        "implementationTitle": "Реализация:",
        "implementationContent": "Настройте Redis в NestJS и используйте его в сервисах.",
        "invalidationTitle": "Ключевой аспект:",
        "invalidationContent": "<strong>Инвалидация кэша</strong>. При изменении данных в БД, удаляйте соответствующие ключи из Redis, чтобы клиенты не получали устаревшие данные."
      },
      "asyncProcessing": {
        "title": "8. Асинхронная Обработка (Kafka): Надежность и Отзывчивость (Принцип 9, 2)",
        "intro": "Используйте <strong>Kafka</strong> для выполнения задач, которые не требуют немедленного ответа пользователю (отправка email, обработка изображений, нотификации, аналитика).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "`kafkajs`.",
        "whyTitle": "Почему:",
        "whyContent": "Kafka — <strong>надежная распределенная система очередей</strong>, гарантирующая доставку сообщений и позволяющая масштабировать обработку задач независимо от основного API (воркеры-консьюмеры).",
        "applicationAreasTitle": "Области применения:",
        "applicationAreasContent": [
          "Обработка изображений/видео после загрузки.",
          "Отправка больших объемов push-уведомлений.",
          "Генерация отчетов или статистики.",
          "Архивирование старых сообщений/файлов."
        ],
        "patternTitle": "Паттерн:",
        "patternContent": "<strong>Producer-Consumer</strong>. Backend-API ставит задачи в топик Kafka (Producer). Отдельные сервисы/воркеры (Consumer) читают задачи из топика и выполняют их в фоновом режиме.",
        "partitioningTitle": "Партиционирование в Kafka:",
        "partitioningContent": "Используйте ключи сообщений (например, `userId`, `chatId`), чтобы сообщения, относящиеся к одному пользователю/чату, попадали в одну партицию. Это гарантирует порядок обработки внутри партиции, что может быть важно для некоторых задач.",
        "monitoringTitle": "Мониторинг:",
        "monitoringContent": "Используйте <strong>Kafdrop</strong> для визуального мониторинга топиков, сообщений и состояния консьюмер-групп."
      },
      "pushNotificationsOptimization": {
        "title": "9. Оптимизация Push-уведомлений (Firebase FCM): Эффективная Доставка Информации (Принцип 2)",
        "intro": "Push-уведомления — важный канал связи с пользователем (Принцип 2: Ценность). Оптимизация их доставки важна для пользовательского опыта.",
        "platformTitle": "Платформа:",
        "platformContent": "Firebase Cloud Messaging (FCM).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Батчинг:</strong> Отправляйте несколько уведомлений одним вызовом API FCM (`sendMulticast`) для снижения сетевых накладных расходов.",
          "<strong>Темы (Topics):</strong> Используйте темы для массовых рассылок (например, уведомление о новом сообщении в канале), чтобы FCM управлял списком подписчиков.",
          "<strong>Data Messages:</strong> Используйте Data Messages для полного контроля над отображением уведомления на клиенте и возможности прикреплять кастомные данные."
        ]
      },
      "clientApiDbInteraction": {
        "title": "10. Оптимизация Взаимодействия Клиент-API-БД: Сокращение Пути Данных (Принцип 9)",
        "intro": "",
        "clientLevelTitle": "На Уровне Клиента:",
        "clientLevelContent": "Используйте библиотеки для управления состоянием и кэширования данных, полученных по сети (`@apollo/client`, `react-query`/`@tanstack/react-query`). Это позволяет избежать повторных запросов за одними и теми же данными и быстро показывать кэшированные данные.",
        "networkLevelTitle": "На Уровне Сети:",
        "networkLevelContent": "Включите современные протоколы (HTTP/2, HTTP/3) и сжатие (Gzip/Brotli) на вашем API Gateway или Backend сервере для уменьшения объема передаваемых данных и снижения задержки.",
        "backendLevelTitle": "На Уровне Backend:",
        "backendLevelContent": "Оптимизируйте взаимодействие с БД (раздел 4) и внешними сервисами (раздел 7)."
      },
      "authenticationOptimization": {
        "title": "11. Оптимизация Аутентификации: Быстрота и Безопасность",
        "intro": "",
        "statelessJwtTitle": "Stateless (JWT):",
        "statelessJwtContent": "Использование JWT снижает нагрузку на сервер, так как ему не нужно хранить состояние сессий пользователей.",
        "rateLimitingTitle": "Rate Limiting (`@nestjs/throttler`):",
        "rateLimitingContent": "Защита эндпоинтов аутентификации от Brute Force атак, что также снижает нагрузку.",
        "secureHeadersTitle": "Безопасные Заголовки (`helmet`):",
        "secureHeadersContent": "Добавление HTTP-заголовков для защиты от XSS, CSRF и других атак."
      },
      "chatWebSocketOptimization": {
        "title": "12. Оптимизация Чатов (WebSocket): Низкая Задержка и Масштабирование",
        "intro": "WebSocket используется для обмена сообщениями в реальном времени. <strong>Оптимизация WebSocket-соединений критична для отзывчивости чатов</strong> (Принцип 2).",
        "libraryTitle": "Библиотека:",
        "libraryContent": "NestJS Gateways (`@nestjs/websockets`), Socket.IO (если нужна кросс-браузерная совместимость и fallback).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Бинарные Форматы:</strong> Передача сообщений в бинарном формате (например, MessagePack) вместо текстового JSON может уменьшить объем данных.",
          "<strong>Батчинг Сообщений:</strong> Буферизируйте сообщения на клиенте и сервере и отправляйте их пачками (например, каждые 50 мс), а не по одному. Снижает количество пакетов.",
          "<strong>Управление Присутствием:</strong> Используйте Redis для быстрого отслеживания статуса онлайн/офлайн пользователей. Heartbeats (пинг-понг) для поддержания соединения и обнаружения отключений.",
          "<strong>Вертикальное/Горизонтальное Масштабирование:</strong> NestJS Gateways могут работать в кластерном режиме. Используйте Redis или другой Pub/Sub механизм (например, Kafka) для обмена сообщениями между инстансами Backend, чтобы сообщения доставлялись всем подписчикам, независимо от того, к какому инстансу Backend они подключены."
        ]
      },
      "animationsOptimization": {
        "title": "13. Оптимизация Анимаций: Плавность и Производительность (Принцип 3, 5)",
        "intro": "Производительные анимации делают интерфейс <strong>качественным</strong> (Принцип 3) и снижают нагрузку на устройство (Принцип 5: Здоровье).",
        "mobileDesktopTitle": "Mobile-Desktop (React Native):",
        "mobileDesktopContent": "Используйте `react-native-reanimated` для анимаций, которые выполняются на нативном потоке, не блокируя поток JavaScript.",
        "webTitle": "Web (Next.js):",
        "webContent": "Используйте `framer-motion` для декларативного создания плавных анимаций.",
        "docDesignTitle": "DocDesign:",
        "docDesignContent": "В DocDesign описаны принципы и параметры анимаций, включая возможность их отключения пользователем (Принцип 12: Прагматизм)."
      },
      "monitoring": {
        "title": "14. Мониторинг с Prometheus и Grafana: Измерение как Основа Кайдзен (Принцип 9)",
        "intro": "Система мониторинга — это ваши <strong>глаза</strong> и <strong>измерительные инструменты</strong> (Шаг 1 Кайдзен).",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Prometheus (сбор метрик), Grafana (визуализация), Alertmanager (уведомления об аномалиях).",
        "whenTitle": "Когда использовать:",
        "whenContent": "Всегда. Настройте мониторинг на всех уровнях: Backend (задержки API, ошибки), БД (время запросов, нагрузка), Redis (попадания в кэш, использование памяти), Kafka (количество сообщений в топиках, лаг консьюмеров), Инфраструктура (CPU, RAM, сеть).",
        "implementationTitle": "Реализация:",
        "implementationContent": "См. подробные шаги по настройке в Руководстве по разработке (раздел 14).",
        "principleTitle": "Принцип:",
        "principleContent": "Используйте метрики для <strong>выявления узких мест</strong> (Шаг 2 Кайдзен) и оценки <strong>эффективности</strong> (Принцип 9) ваших оптимизаций. Настройте <strong>алерты</strong> для проактивного обнаружения проблем."
      },
      "ciCdOptimization": {
        "title": "15. Оптимизация CI/CD: Ускорение Цикла Разработки (Принцип 9)",
        "intro": "Эффективный CI/CD пайплайн ускоряет доставку кода, что является частью <strong>оптимизации всего процесса разработки</strong> (Принцип 9).",
        "toolsTitle": "Инструменты:",
        "toolsContent": "Turborepo (кэширование, параллелизация), GitHub Actions (автоматизация).",
        "techniquesTitle": "Техники:",
        "techniquesContent": [
          "<strong>Кэширование с Turborepo:</strong> Кэшируйте результаты сборки и тестов между запусками в CI и локально.",
          "<strong>Параллельное выполнение:</strong> Запускайте задачи (lint, build, test) для разных пакетов или частей тестов параллельно.",
          "<strong>Оптимизация Docker-образов:</strong> Используйте многоступенчатую сборку и `.dockerignore` для уменьшения размера образов и ускорения сборки/деплоя."
        ]
      },
      "frontendOptimization": {
        "title": "16. Оптимизация Фронтенда: Быстрота и Отзывчивость для Пользователя (Принцип 2, 3)",
        "intro": "Фронтенд должен быть <strong>быстрым и отзывчивым</strong>, чтобы пользователь ощутил <strong>ценность</strong> (Принцип 2) продукта.",
        "webTechniquesTitle": "Техники (Web - Next.js):",
        "webTechniquesContent": [
          "<strong>Code Splitting / Dynamic Imports:</strong> Загружайте код только тогда, когда он нужен (`next/dynamic`).",
          "<strong>SSR/SSG:</strong> Используйте серверный рендеринг или генерацию статики для ускорения первой отрисовки и SEO (`getStaticProps`, `getServerSideProps`).",
          "<strong>Оптимизация Изображений:</strong> Используйте `next/image` или `<picture>` и современные форматы (WebP).",
          "<strong>Анализ Бандла:</strong> Используйте `@next/bundle-analyzer` для выявления самых тяжелых модулей."
        ],
        "reactNativeTechniquesTitle": "Техники (React Native):",
        "reactNativeTechniquesContent": [
          "<strong>Ленивая Загрузка:</strong> Используйте `React.lazy` и `Suspense` для экранов и компонентов, которые не нужны при старте.",
          "<strong>Производительные Списки:</strong> Используйте `FlatList` или `SectionList` с правильной настройкой (`getItemLayout`, `windowSize`) для больших списков сообщений или чатов.",
          "<strong>Оптимизация Изображений:</strong> Используйте `react-native-fast-image`.",
          "<strong>Профилирование:</strong> Используйте Performance Monitor в Debugger Menu React Native для выявления узких мест UI."
        ],
        "generalTechniquesTitle": "Общие техники:",
        "generalTechniquesContent": [
          "Удаление неиспользуемого кода (Tree Shaking), замена тяжелых библиотек на легкие аналоги (например, `dayjs` вместо `moment`), сжатие бандлов (Gzip/Brotli)."
        ]
      },
      "dbScaling": {
        "title": "17. Масштабирование Базы Данных (Репликация и Шардинг): Подготовка к Росту (Принцип 8)",
        "intro": "Эти техники становятся актуальными при значительном росте объема данных и нагрузки. Они являются частью <strong>долгосрочной стратегии масштабирования</strong> (Принцип 8).",
        "replicationTitle": "Репликация (Master-Slave):",
        "replicationContent": "Создание копий БД только для чтения (read replicas). Позволяет распределить нагрузку на чтение.",
        "shardingTitle": "Шардинг:",
        "shardingContent": "Разделение данных большой таблицы на части (шарды) по определенному ключу (`chatId`, `userId`), распределяя их по разным серверам. Позволяет масштабировать как чтение, так и запись. Реализуется логически (в приложении) или с помощью расширений (Citus для PostgreSQL).",
        "whenToApplyTitle": "Когда применять:",
        "whenToApplyContent": "Основываясь на <strong>измерениях</strong> нагрузки и производительности БД (Принцип 9), а не заранее."
      },
      "notes": {
        "title": "18. Примечания: Непрерывный Кайдзен в Оптимизации",
        "prioritizationTitle": "Приоритезация:",
        "prioritizationContent": "Начинайте оптимизацию с тех мест, которые приносят наибольший эффект на текущем этапе проекта (Принцип 12). Для MVP это может быть скорость загрузки Frontend, производительность основных API-запросов.",
        "automationTitle": "Автоматизация:",
        "automationContent": "Максимально автоматизируйте процессы измерения и проверки оптимизаций (CI/CD, алерты в мониторинге) — это часть <strong>Системы</strong> (Принцип 9).",
        "documentationNotesTitle": "Документирование:",
        "documentationNotesContent": "Фиксируйте проведенные оптимизации, их эффект и уроки в этой документации или в задачах/коммитах (Принцип 1: Обучение, Принцип 9: Кайдзен).",
        "cultureTitle": "Культура:",
        "cultureContent": "Создайте культуру, где каждый разработчик несет ответственность за производительность своего кода и активно участвует в поиске и устранении узких мест (Принцип 6)."
      }
    }
}
